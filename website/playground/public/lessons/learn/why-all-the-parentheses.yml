sections:
  - id: dOJ4UijU
    type: text
    value: >-
      # Why all the parentheses?


      Great job for making it this far in the guide! The lessons after this one
      let you do some really cool things with Wipple, but the code is also a bit
      more complex. Before you continue, this section aims to clear up any
      confusion about where you use parentheses and hopefully make programming
      in Wipple a bit more intuitive.


      Let's go back to our very first program:
    locked: true
  - id: HT3HQD13
    type: code
    value: show (2 + 2)
  - id: GyYh5DKc
    type: text
    value: >-
      Have you ever thought about why we need parentheses around the `2 + 2`?
      Well, let's see what happens without them:
    locked: true
  - id: eIAzvZdS
    type: code
    value: show 2 + 2
  - id: apBrX_2s
    type: text
    value: >+
      Wipple's type system can help us out a lot here. We can see that the left
      hand side has type `()`, and the right hand side has type `Number`. (As
      you may recall, `()` is the output of `show`!) You can't add `()` to a
      number — it just doesn't make sense!


      Operators, like `+` and `->` and `:`, are "greedy"; they try to consume as
      much input as they can from either side. So writing `show 2 + 2` is
      equivalent to writing `(show 2) + 2`. But that still doesn't answer the
      question of why we need the parentheses in the first place.


      ## Parentheses and values


      The key thing to know is that in Wipple (and most other programming
      languages), a group of parentheses indicates a _single_ value, where a
      value is the _result_ of your code (what it produces as output). When
      Wipple runs our code, it does so from the inside out, left to right. Let's
      create some functions so we can see what's going on!

    locked: true
  - id: 73IKXDNR
    type: code
    value: "number : n -> {\n\tshow n\n\tn\n}\n\nadd : a -> b -> {\n\tshow \"add\"\n\ta + b\n}\n\nsubtract : a -> b -> {\n\tshow \"subtract\"\n\ta - b\n}\n\nshow (add (subtract (number 5) (number 3)) (number 6))"
  - id: A9X6yYUN
    type: text
    value: >-
      Before you go any further, try enabling **beginner mode** in the bottom
      left of the screen. Beginner mode highlights matching parentheses in
      different colors, so it's easier to see each value. Hopefully the above
      example is a bit clearer now!


      Remember, the key insight is that Wipple evaluates parentheses inside out,
      left to right, producing a _single value_ for each set of parentheses.
      Every Wipple function accepts a _single value_ as input and produces a
      _single value_ as output.


      ...but hold on, we learned a long time ago that functions can produce
      other functions! That's how we can build functions that work with multiple
      inputs. Well, it turns out that **functions are values too**, just like
      numbers and text!


      Hmm, if functions are values, does that mean we can assign them to
      variables?
    locked: true
  - id: fqV1HFI_
    type: code
    value: 'increment : a -> a + 1'
    lint: false
  - id: GjrFl7yb
    type: text
    value: "That's exactly what we've been doing all along! Many beginners think that functions are \"special\", and when you assign them to a name, you're giving that piece of code a name. That's not true —\_**functions are just values**, and `:` always creates a variable that holds a value. There's no magic going on!\n\nWell functions accept values, right? Can we make functions that output other functions?"
    locked: true
  - id: ljCumMX2
    type: code
    value: |-
      add : (a -> (b -> a + b))
      show ((add 1) 2)
  - id: baJQv0vS
    type: text
    value: "Yes we can —\_we've been doing it all along, too! You don't need the parentheses in this example, but they help reinforce the idea that you're just making a value. The `->` operator behaves the same way as the `+` operator, taking something from the left and the right and producing a value.\n\nAlright, how about functions that take functions as input?"
    locked: true
  - id: '-k2S--4P'
    type: code
    value: |-
      call : (function -> (input -> (function input)))
      increment : (x -> (x + 1))
      show (call increment 1)
  - id: WVyWaAcD
    type: text
    value: "Woah! If you aren't convinced, try hovering over `call` to see that it accepts a `Number -> Number` as its input! Notice that `Number -> (Number -> Number)`, which accepts two numbers and produces a number, is different from `(Number -> Number) -> Number`, which accepts a single _function_ and produces a number.\n\nYou don't have to give your functions names, either —\_just pass them directly:"
    locked: true
  - id: ojJqcr_1
    type: code
    value: |-
      call : (function -> (input -> (function input)))
      show (call (x -> (x + 1)) 1)
  - id: COj4AhuH
    type: text
    value: >-
      ## Dot notation


      Often, functions have a "primary" input, an input that the function
      operates on. To understand why that's useful, let's turn our attention to
      the `times` function:
    locked: true
  - id: LCOPPr20
    type: code
    value: times show 4
  - id: GxzNP5j9
    type: text
    value: "The `times` function works by accepting a function and a number ($n$), and calling that function repeatedly from zero to $n$. It's clear here that the `4` we provided to `times` is the \"primary\" input —\_it's what decides how many times `show` is called! So we can use a `.` to put the `4` in front, like so:"
    locked: true
  - id: sx3NBbRJ
    type: code
    value: 4 . times show
  - id: eWc0lxPO
    type: text
    value: >-
      Now it's clear to the reader that we can change the `4` to change how many
      times `show` is called. If we want to do something more custom, we can
      provide a function to `times` directly:
    locked: true
  - id: gm-KVBxY
    type: code
    value: 4 . times (n -> show (format "_ * 2 = _" n (n * 2)))
  - id: 6Rjk9iBp
    type: text
    value: 'Compare that to writing it without using `.` notation:'
    locked: true
  - id: SuPJ2W2n
    type: code
    value: times (n -> show (format "_ * 2 = _" n (n * 2))) 4
  - id: Gq4BevS3
    type: text
    value: >-
      Now the `4` is all the way at the end, making it difficult to see how many
      times our code is run.


      It takes some practice to figure out when to use `.` notation and when to
      skip it, but in general, just do whatever is more readable to you!


      One last note: if you just want to run some code a specific number of
      times, you don't have to use the `n` provided to you by `times`. Instead,
      you can ignore it by using `_` (just like in `when`):
    locked: true
  - id: Y4YREAkB
    type: code
    value: 4 . times (_ -> show "Hello, world!")
  - id: 2UvMfaeh
    type: text
    value: >-
      You will see this pattern often in future lessons!


      Before you press the right arrow, try playing around with parentheses,
      functions and values in the space below. Make sure you're really satisfied
      with this idea that everything is just a value. And you can always use
      beginner mode to see how your code is structured beneath all those
      parentheses!
    locked: true
  - id: WopgW9Eu
    type: code
    value: ''
previous:
  name: Enumerations and pattern matching
  link: ?lesson=learn/enumerations-and-pattern-matching
next:
  name: Maybe and Result
  link: ?lesson=learn/maybe-and-result
