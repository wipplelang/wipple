[[no-implicit-use]]

use "math"
use "list"
use "sequence"

Entry : Key Value => type {
  key :: Key
  value :: Value
}

[help "Associate a key with a value."]
[help-group "Collections"]
[operator Association-Precedence]
(:) : syntax {
  'key : 'value -> Entry {
    key : 'key
    value : 'value
  }
}

[help "Combine the number generated by `Hash` into the state of a `Hasher`."]
[help-group "Collections"]
hash :: Natural -> Hasher -> Hasher
hash : next hasher -> intrinsic "hash-into-hasher" hasher next

[help "Convert the components of a value into a number used by `Dictionary` and `Set` to organize their elements."]
[help-group "Collections"]
Hash : A => trait (A -> Hasher -> Hasher)

instance (Hash Natural) : hash
instance (Hash Number) : n -> hash (intrinsic "hash-number" n)
instance (Hash Integer) : n -> hash (intrinsic "hash-integer" n)
instance (Hash Byte) : n -> hash (intrinsic "hash-byte" n)
instance (Hash Signed) : n -> hash (intrinsic "hash-signed" n)
instance (Hash Unsigned) : n -> hash (intrinsic "hash-unsigned" n)
instance (Hash Float) : n -> hash (intrinsic "hash-float" n)
instance (Hash Double) : n -> hash (intrinsic "hash-double" n)
instance (Hash Text) : t -> hash (intrinsic "hash-text" t)
instance (Hash ()) : () -> hash 0

[sealed]
Dictionary : Key Value => type {
  hasher :: Hasher
  size :: Natural
  entries :: List (Maybe (Entry Key Value))
}

instance (Default (Dictionary _ _)) : Dictionary {
  hasher : intrinsic "make-hasher"
  size : 0
  entries : Default . append None
}

[help "Retrieve the value for a key stored in a `Dictionary`."]
entry :: Key Value where (Equal Key) (Hash Key) => Key -> Dictionary Key Value -> Maybe Value
entry : key { hasher entries } -> {
  index : mutable ((intrinsic "value-of-hasher" (Hash key hasher)) mod count entries)

  repeat {
    when (entries . nth (get index) . unwrap) {
      Some {
        key : existing-key
        value
      } -> if (key = existing-key) (Break (Some value)) {
        index . set! ((get index + 1) mod count entries)
        Continue
      }
      None -> Break None
    }
  }
}

[help "Add a new entry to a `Dictionary`."]
[help-group "Collections"]
insert :: Key Value where (Hash Key) => Entry Key Value -> Dictionary Key Value -> Dictionary Key Value
insert : { key value } { hasher size entries } -> {
  dictionary : if (size >= count entries / 2) {
    -- Double the size of the dictionary
    resized : Dictionary {
      hasher
      size : 0
      entries : sequence (Some None) . take (count entries * 2) . collect
    }

    entries . reduce resized (entry dictionary -> when entry {
      Some entry -> dictionary . insert entry
      None -> dictionary
    })
  } {
    Dictionary {
      hasher
      size : size + 1
      entries
    }
  }

  dictionary . set-entry key (Some value)
}

[help "Add a new entry to a `Mutable Dictionary`."]
[help-group "Collections"]
insert! :: Key Value where (Hash Key) => Entry Key Value -> Mutable (Dictionary Key Value) -> ()
insert! : entry dictionary -> dictionary . set! (get dictionary . insert entry)

[help "Remove an entry from a `Dictionary`."]
[help-group "Collections"]
remove :: Key Value where (Hash Key) => Key -> Dictionary Key Value -> Dictionary Key Value
remove : key { hasher size entries } -> {
  dictionary : Dictionary {
    hasher
    size : if (size = 0) 0 (size - 1)
    entries
  }

  dictionary . set-entry key None
}

[help "Remove an entry from a `Mutable Dictionary`."]
[help-group "Collections"]
remove! :: Key where (Hash Key) => Key -> Mutable (Dictionary Key _) -> ()
remove! : key dictionary -> dictionary . set! (get dictionary . remove key)

[private]
set-entry :: Key Value where (Hash Key) => Key -> Maybe Value -> Dictionary Key Value -> Dictionary Key Value
set-entry : key value { hasher size entries } -> {
  index : mutable ((intrinsic "value-of-hasher" (Hash key hasher)) mod count entries)

  -- Find a spot for the entry
  repeat {
    when (entries . nth (get index) . unwrap) {
      Some _ -> {
        index . set! ((get index + 1) mod count entries)
        Continue
      }
      None -> Break ()
    }
  }

  entry : when value {
    Some value -> Some (key : value)
    None -> None
  }

  entries : entries \
    . remove-at (get index) \
    . unwrap

  entries : entries \
    . insert-at (get index) entry \
    . unwrap

  Dictionary {
    hasher
    size
    entries
  }
}
