[[no-implicit-use]]

use "math"
use "list"
use "sequence"

[help "Combine the number generated by `Hash` into the state of a `Hasher`."]
[help-group "Collections"]
hash :: Natural -> Hasher -> Hasher
hash : next hasher -> intrinsic "hash-into-hasher" hasher next

[help "Convert the components of a value into a number used by `Dictionary` and `Set` to organize their elements."]
[help-group "Collections"]
Hash : A => trait (A -> Hasher -> Hasher)

instance (Hash Natural) : hash
instance (Hash Number) : n -> hash (intrinsic "hash-number" n)
instance (Hash Integer) : n -> hash (intrinsic "hash-integer" n)
instance (Hash Byte) : n -> hash (intrinsic "hash-byte" n)
instance (Hash Signed) : n -> hash (intrinsic "hash-signed" n)
instance (Hash Unsigned) : n -> hash (intrinsic "hash-unsigned" n)
instance (Hash Float) : n -> hash (intrinsic "hash-float" n)
instance (Hash Double) : n -> hash (intrinsic "hash-double" n)
instance (Hash Text) : t -> hash (intrinsic "hash-text" t)
instance (Hash ()) : () -> hash 0

[help "A collection of unique keys associated with values."]
[help-group "Collections"]
[sealed]
Dictionary : Key Value => type {
  hasher :: Hasher
  size :: Natural
  entries :: List (Maybe (Key ; Value))
}

instance (Default (Dictionary _ _)) : Dictionary {
  hasher : intrinsic "make-hasher"
  size : 0
  entries : Default . append None
}

[help "Retrieve the value for a key stored in a `Dictionary`."]
[help-group "Collections"]
entry :: Key Value where (Equal Key) (Hash Key) => Key -> Dictionary Key Value -> Maybe Value
entry : key { hasher entries } -> {
  initial-index : ((intrinsic "value-of-hasher" (Hash key hasher)) mod count entries)
  index : mutable initial-index

  repeat {
    when (entries . nth (get index) . unwrap) {
      Some (existing-key ; value) -> if (key = existing-key) (Break (Some value)) {
        index . set! ((get index + 1) mod count entries)
        if (get index = initial-index) (Break None) Continue
      }
      None -> Break None
    }
  }
}

[help "Add a new entry to a `Dictionary`."]
[help-group "Collections"]
insert-entry :: Key Value where (Equal Key) (Hash Key) => (Key ; Value) -> Dictionary Key Value -> Dictionary Key Value
insert-entry : (key ; value) { hasher size entries } -> {
  dictionary : if (size >= count entries / 2) {
    -- Double the size of the dictionary
    resized : Dictionary {
      hasher
      size : 0
      entries : sequence (Some None) . take (count entries * 2) . collect
    }

    entries . reduce resized (entry dictionary -> when entry {
      Some entry -> dictionary . insert-entry entry
      None -> dictionary
    })
  } {
    Dictionary {
      hasher
      size : size + 1
      entries
    }
  }

  dictionary . set-entry key (Some value)
}

[help "Add a new entry to a `Mutable Dictionary`."]
[help-group "Collections"]
insert-entry! :: Key Value where (Equal Key) (Hash Key) => (Key ; Value) -> Mutable (Dictionary Key Value) -> ()
insert-entry! : entry dictionary -> dictionary . set! (get dictionary . insert-entry entry)

[help "Remove an entry from a `Dictionary`."]
[help-group "Collections"]
remove-entry :: Key Value where (Equal Key) (Hash Key) => Key -> Dictionary Key Value -> Dictionary Key Value
remove-entry : key { hasher size entries } -> {
  dictionary : Dictionary {
    hasher
    size : if (size = 0) 0 (size - 1)
    entries
  }

  dictionary . set-entry key None
}

[help "Remove an entry from a `Mutable Dictionary`."]
[help-group "Collections"]
remove-entry! :: Key where (Equal Key) (Hash Key) => Key -> Mutable (Dictionary Key _) -> ()
remove-entry! : key dictionary -> dictionary . set! (get dictionary . remove-entry key)

[private]
set-entry :: Key Value where (Equal Key) (Hash Key) => Key -> Maybe Value -> Dictionary Key Value -> Dictionary Key Value
set-entry : key value { hasher size entries } -> {
  index : mutable ((intrinsic "value-of-hasher" (Hash key hasher)) mod count entries)

  -- Find a spot for the entry
  repeat {
    when (entries . nth (get index) . unwrap) {
      Some (existing ; _) -> {
        if (key = existing) {
          Break ()
        } {
          index . set! ((get index + 1) mod count entries)
          Continue
        }
      }
      None -> Break ()
    }
  }

  entry : when value {
    Some value -> Some (key ; value)
    None -> None
  }

  entries : entries \
    . remove-at (get index) \
    . unwrap

  entries : entries \
    . insert-at (get index) entry \
    . unwrap

  Dictionary {
    hasher
    size
    entries
  }
}

Key Value where (Equal Key) (Hash Key) => instance (From-Sequence (Key ; Value) (Dictionary Key Value)) : seq -> {
  dictionary : mutable Default
  repeat {
    when (next seq) {
      Some entry -> {
        dictionary . insert-entry! entry
        Continue
      }
      None -> Break ()
    }
  }

  get dictionary
}

Key Value => instance (As-Sequence (Dictionary Key Value) (Key ; Value)) : dictionary -> (((entries of dictionary) . As-Sequence) :: Sequence (Maybe (_ ; _))) . flatten

Key Value where (Equal Key) (Hash Key) => instance (Container (Dictionary Key Value) Key) : target -> entry target | (is Some _)

[help "A collection of unique elements."]
[help-group "Collections"]
[sealed]
Set : Element => type {
  dictionary :: Dictionary Element ()
}

instance (Default (Set _)) : Set { dictionary : Default }

[help "Add a new element to a `Set`."]
[help-group "Collections"]
insert :: Element where (Equal Element) (Hash Element) => Element -> Set Element -> Set Element
insert : element { dictionary } -> Set { dictionary : dictionary . insert-entry (element ; ()) }

[help "Add a new element to a `Mutable Set`."]
[help-group "Collections"]
insert! :: Element where (Equal Element) (Hash Element) => Element -> Mutable (Set Element) -> ()
insert! : entry set -> set . set! (get set . insert entry)

[help "Remove an element from a `Set`."]
[help-group "Collections"]
remove :: Element where (Equal Element) (Hash Element) => Element -> Set Element -> Set Element
remove : element { dictionary } -> Set { dictionary : dictionary . remove-entry element }

[help "Remove an element from a `Mutable Set`."]
[help-group "Collections"]
remove! :: Element where (Equal Element) (Hash Element) => Element -> Mutable (Set Element) -> ()
remove! : entry set -> set . set! (get set . remove entry)

Element where (Equal Element) (Hash Element) => instance (From-Sequence Element (Set Element)) : seq -> Set { dictionary : seq . transform (key -> (key ; ())) . collect }
Element => instance (As-Sequence (Set Element) Element) : { dictionary } -> dictionary . transform ((key ; _) -> key)
Element where (Equal Element) (Hash Element) => instance (Container (Set Element) Element) : target -> (dictionary of) | entry target | (is Some _)
