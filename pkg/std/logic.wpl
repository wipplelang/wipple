[[no-std]]

[language "boolean"]
[help "Represents either `True` or `False`."]
Boolean : type {
	False
	True
}

use Boolean

if : bool then else ~> when bool {
	False -> else
	True -> then
}

if? : bool then ~> if bool then ()

[help "Returns `False` if provided `True`, and vice versa."]
not :: Boolean -> Boolean
not : bool -> if bool False True

And : Left Right Output => trait (Left -> (() -> Right) -> Output)
and : conjunction operator (a b ~> And a (() -> b))
instance And Boolean Boolean Boolean : a? -> b? -> if a? (b? ()) False

Or : Left Right Output => trait (Left -> (() -> Right) -> Output)
-- `or` operator is defined in the compiler to accommodate `or` patterns
instance Or Boolean Boolean Boolean : a? -> b? -> if a? True (b? ())

[help "The result of a comparison between two values."]
Ordering : type {
	Less
	Equal
	Greater
}

[help "Implement this trait to enable comparisons between two values of your type."]
Order : A => trait (A -> A -> Ordering)

instance Order Number : a -> b -> external "builtin" "number-ordering" a b

< : comparison operator (a b ~> when (Order a b) {
	Ordering Less -> True
	Ordering Equal -> False
	Ordering Greater -> False
})

> : comparison operator (a b ~> when (Order a b) {
	Ordering Less -> False
	Ordering Equal -> False
	Ordering Greater -> True
})

<= : comparison operator (a b ~> when (Order a b) {
	Ordering Less -> True
	Ordering Equal -> True
	Ordering Greater -> False
})

>= : comparison operator (a b ~> when (Order a b) {
	Ordering Less -> False
	Ordering Equal -> True
	Ordering Greater -> True
})

[help "Implement this trait to enable equality testing between two values of your type."]
Equal : A => trait (A -> A -> Boolean)
= : comparison operator (a b ~> Equal a b)
/= : comparison operator (a b ~> not (a = b))

instance Equal Number : a -> b -> when (Order a b) {
	Ordering Less -> False
	Ordering Equal -> True
	Ordering Greater -> False
}

instance Equal Text : a -> b -> external "builtin" "text-equality" a b
instance Equal () : () -> () -> True
instance Equal Boolean : a? -> b? -> a? and b? or not a? and not b?
