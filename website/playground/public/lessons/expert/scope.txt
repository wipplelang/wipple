---
next:
  name: Attributes
  link: ?lesson=expert/attributes
---

---
id: FvDmC08O
type: text
locked: true
---

# Scope

In this lesson, we'll take a look at how Wipple organizes variables using **scope**. In Wipple, variable assignment using `:` is actually shorthand for using `when`:

---
id: EUsu1CXP
type: code
---

-- This:
x : 42
show x

-- Is equivalent to:
when 42 {
    x -> show x
}

---
id: d2egJ1s7
type: text
locked: true
---

As a consequence, you can only access a variable inside the block in which it was defined (and all sub-blocks). If you declare multiple variables inside a single block, the variables are defined top to bottom. Here's another example:

---
id: Jh3sbxyy
type: code
---

-- This:
a : 1
b : 2
sum : a + b
show sum

-- Is equivalent to:
when 1 {
    a -> when 2 {
        b -> when (a + b) {
            sum -> show sum
        }
    }
}

---
id: oGd00ZPB
type: text
locked: true
---

## Shadowing

Although you can't change a variable after you define it, Wipple allows you to reuse, or **shadow** variable names. The new variable is completely different from the old variable and doesn't need to have the same type — you just can't access the original variable in that scope anymore.

---
id: reMTGidS
type: code
---

number : 1
number : number + 1
show number

---
id: caoqs-vw
type: text
locked: true
---

In the above example, you might as well pretend that the variable is being reassigned. But watch what happens when we capture the variable in a function before redeclaring it:

---
id: phcJwSNQ
type: code
lint: true
---

number : 1
show-number : () -> show number
number : number + 1
show-number ()

---
id: 532_gDr6
type: text
locked: true
---

`show-number` always refers to the `number` declared before `show-number` itself was declared. In fact, Wipple even tells us that the second `number` is never used!

If you really need to be able to change `number`'s value and have it be observed everywhere, you can use `mutable` — see the Advanced lesson on mutability for more details!

## Instances

The only kind of variable you can't shadow is a variable created by `instance`. You can only refer to `instance`s through the use of a trait, and Wipple doesn't normally allow you to have two instances that share the same type:

---
id: FgIhfALb
type: code
---

X : type

instance (Show X) : _ -> "instance 1"
instance (Show X) : _ -> "instance 2"

---
id: C87C5SvS
type: text
locked: true
---

If you really need overlapping instances, you can put the `[sealed]` and `[allow-overlapping-instances]` **attributes** on your trait. This tells Wipple to disable checking for conflicts and just use the first instance that matches. We'll talk about attributes more in the next lesson.

---
id: PQANcFe_
type: code
---

X : type

[sealed]
[allow-overlapping-instances]
My-Show : A => trait (A -> Text)

instance (My-Show X) : _ -> "instance 1"
instance (My-Show X) : _ -> "instance 2"

show (My-Show X)

---
id: FC5P82Ly
type: text
locked: true
---

You normally don't need to use `allow-overlapping-instances`, but if you're writing extremely generic code with assumptions you can't fully encode as types, Wipple's type system might get confused. We'll see an example where `allow-overlapping-instances` is necessary in an upcoming lesson!
