[[no-std]]

[language "boolean"]
[help "Represents either `True` or `False`."]
[help-group "Logic"]
Boolean : type {
  False
  True
}

[help "Choose between two values depending on whether the input is `True` or `False`."]
[help-group "Control Flow"]
[keyword]
if : syntax {
  if 'bool 'then 'else -> when 'bool {
    True -> 'then
    False -> 'else
  }
  if 'bool 'then -> if 'bool 'then ()
}

[help "Returns `False` if provided `True`, and vice versa."]
[help-group "Logic"]
not :: Boolean -> Boolean
not : bool -> if bool False True

And : Left Right (infer Output) => trait (Left -> (() -> Right) -> Output)

[help "Returns `True` if both sides are `True`."]
[help-group "Logic"]
[operator Conjunction-Precedence]
and : syntax { 'a and 'b -> And 'a (() -> 'b) }

instance (And Boolean Boolean Boolean) : a? -> b? -> if a? (b? ()) False

Or : Left Right (infer Output) => trait (Left -> (() -> Right) -> Output)

[help "Returns `True` if either side is `True`."]
[help-group "Logic"]
[operator Disjunction-Precedence]
or : syntax { 'a or 'b -> Or 'a (() -> 'b) }

instance (Or Boolean Boolean Boolean) : a? -> b? -> if a? True (b? ())

[help "The result of a comparison between two values."]
[help-group "Logic"]
Ordering : type {
  Less
  Equal
  Greater
}

[help "Implement this trait to enable comparisons between two values of your type."]
[help-group "Logic"]
Order : A => trait (A -> A -> Ordering)

instance (Order Number) : a b -> intrinsic "number-ordering" a b
instance (Order Integer) : a b -> intrinsic "integer-ordering" a b
instance (Order Natural) : a b -> intrinsic "natural-ordering" a b
instance (Order Byte) : a b -> intrinsic "byte-ordering" a b
instance (Order Signed) : a b -> intrinsic "signed-ordering" a b
instance (Order Unsigned) : a b -> intrinsic "unsigned-ordering" a b
instance (Order Float) : a b -> intrinsic "float-ordering" a b
instance (Order Double) : a b -> intrinsic "double-ordering" a b

[help "Returns `True ` if the left side is less than the right side."]
[help-group "Logic"]
[operator Comparison-Precedence]
< : syntax {
  'a < 'b -> when (Order 'a 'b) {
    Ordering Less -> True
    Ordering Equal -> False
    Ordering Greater -> False
  }
}

[help "Returns `True ` if the left side is greater than the right side."]
[help-group "Logic"]
[operator Comparison-Precedence]
> : syntax {
  'a > 'b -> when (Order 'a 'b) {
    Ordering Less -> False
    Ordering Equal -> False
    Ordering Greater -> True
  }
}

[help "Returns `True ` if the left side is less than or equal to the right side."]
[help-group "Logic"]
[operator Comparison-Precedence]
<= : syntax {
  'a <= 'b -> when (Order 'a 'b) {
    Ordering Less -> True
    Ordering Equal -> True
    Ordering Greater -> False
  }
}

[help "Returns `True ` if the left side is greater than or equal to the right side."]
[help-group "Logic"]
[operator Comparison-Precedence]
>= : syntax {
  'a >= 'b -> when (Order 'a 'b) {
    Ordering Less -> False
    Ordering Equal -> True
    Ordering Greater -> True
  }
}

[help "Implement this trait to enable equality testing between two values of your type."]
[help-group "Logic"]
Equal : A => trait (A -> A -> Boolean)

[help "Returns `True ` if both sides are equal."]
[help-group "Logic"]
[operator Comparison-Precedence]
= : syntax { 'a = 'b -> Equal 'a 'b }

[help "Returns `True ` if the left side is not equal to the right side."]
[help-group "Logic"]
[operator Comparison-Precedence]
/= : syntax { 'a /= 'b -> not ('a = 'b) }

instance (Equal Text) : a b -> intrinsic "text-equality" a b
instance (Equal Number) : a b -> intrinsic "number-equality" a b
instance (Equal Integer) : a b -> intrinsic "integer-equality" a b
instance (Equal Natural) : a b -> intrinsic "natural-equality" a b
instance (Equal Byte) : a b -> intrinsic "byte-equality" a b
instance (Equal Signed) : a b -> intrinsic "signed-equality" a b
instance (Equal Unsigned) : a b -> intrinsic "unsigned-equality" a b
instance (Equal Float) : a b -> intrinsic "float-equality" a b
instance (Equal Double) : a b -> intrinsic "double-equality" a b
instance (Equal ()) : () -> () -> True
instance (Equal Boolean) : a b -> if a b (not b)

Numeric-Impl : N => type { zero :: N }

Numeric : N => trait (Numeric-Impl N)

instance (Numeric Number) : Numeric-Impl { zero : 0 }

instance (Numeric Integer) : Numeric-Impl { zero : 0 }

instance (Numeric Natural) : Numeric-Impl { zero : 0 }

instance (Numeric Byte) : Numeric-Impl { zero : 0 }

instance (Numeric Signed) : Numeric-Impl { zero : 0 }

instance (Numeric Unsigned) : Numeric-Impl { zero : 0 }

instance (Numeric Float) : Numeric-Impl { zero : 0 }

instance (Numeric Double) : Numeric-Impl { zero : 0 }
