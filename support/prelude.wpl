-- Functional programming --

it :: A => A -> A
it : x -> x

just :: A B => A -> B -> A
just : x -> _ -> x

. : dot operator (x f ~> f x)

-- Logic --

Boolean : type {
	False
	True
}

use Boolean

if : bool then else ~> when bool {
	False -> else
	True -> then
}

not :: Boolean -> Boolean
not : bool -> if bool False True

And : Left Right Output => trait (Left -> (() -> Right) -> Output)
and : conjunction operator (a b ~> And a (() -> b))
instance And Boolean Boolean Boolean : a? -> b? -> if a? (b? ()) False

Or : Left Right Output => trait (Left -> (() -> Right) -> Output)
or : disjunction operator (a b ~> Or a (() -> b))
instance Or Boolean Boolean Boolean : a? -> b? -> if a? True (b? ())

Equal : A => trait (A -> A -> Boolean)
= : comparison operator (a b ~> Equal a b)
/= : comparison operator (a b ~> not (a = b))
instance Equal Number : a -> b -> external "builtin" "number-equality" a b
instance Equal Text : a -> b -> external "builtin" "text-equality" a b
instance Equal () : () -> () -> True
instance Equal Boolean : a? -> b? -> a? and b? or not a? and not b?

Less-Than : A => trait (A -> A -> Boolean)
< : comparison operator (a b ~> Less-Than a b)
instance Less-Than Number : a -> b -> external "builtin" "number-less-than" a b

Greater-Than : A => trait (A -> A -> Boolean)
> : comparison operator (a b ~> Greater-Than a b)
instance Greater-Than Number : a -> b -> external "builtin" "number-greater-than" a b

<= : comparison operator (a b ~> a < b or a = b)
>= : comparison operator (a b ~> a > b or a = b)

-- Output --

Show : A => trait (A -> Text)
instance Show Text : it
instance Show Number : n -> external "builtin" "number-to-text" n
instance Show Boolean : x? -> if x? "True" "False"

show :: A where (Show A) => A -> ()
show : x -> external "builtin" "show" (Show x)

-- Utilities --

crash :: Text -> !
crash : message -> external "builtin" "crash" message

-- Placeholder value: this works because constants are lazily evaluated
... :: !
... : crash "not yet implemented"

Default : A => trait A
instance Default Number : 0
instance Default Text : ""
instance Default Boolean : False

Maybe : Value => type {
	Some Value
	None
}

use Maybe

Value where (Show Value) => instance Show (Maybe Value) : x? -> when x? {
	Some x -> format "Some _" (Show x)
	None -> "None"
}

Result : Success Failure => type {
	OK Success
	Error Failure
}

use Result

Success Failure where (Show Success) (Show Failure) =>
	instance Show (Result Success Failure) :
		x? -> when x? {
		OK x -> format "OK _" (Show x)
		Error e -> format "Error _" (Show e)
	}

-- TODO: Use higher-kinded types
Expect : Container Value => trait (Text -> Container -> Value)

Value => instance Expect (Maybe Value) Value : message -> x? -> when x? {
	Some x -> x
	None -> crash message
}

Success Failure where (Show Failure) =>
	instance Expect (Result Success Failure) Success :
		message -> x? -> when x? {
			OK x -> x
			Error e -> crash (format "_: _" message e)
		}

Unwrap-Message : Container => trait (Container -> Text)

Value => instance Unwrap-Message (Maybe Value) :
	just "called `unwrap` on `None`"

Success Failure => instance Unwrap-Message (Result Success Failure) :
	just "called `unwrap` on `Error`"

-- TODO: Use higher-kinded types
expect :: Container Value where (Expect Container Value) =>
	Text -> Container -> Value
expect : Expect

-- TODO: Use higher-kinded types
unwrap :: Container Value
	where (Expect Container Value) (Unwrap-Message Container) =>
	Container -> Value
unwrap : x? -> expect (Unwrap-Message x?) x?

-- Math --

Add : Left Right Sum => trait (Left -> Right -> Sum)
+ : addition operator (a b ~> Add a b)
instance Add Number Number Number : a -> b -> external "builtin" "add" a b
instance Add Text Text Text : a -> b -> format "__" a b

Subtract : Left Right Difference => trait (Left -> Right -> Difference)
- : addition operator (a b ~> Subtract a b)
instance Subtract Number Number Number : a -> b -> external "builtin" "subtract" a b

Multiply : Left Right Product => trait (Left -> Right -> Product)
* : multiplication operator (a b ~> Multiply a b)
instance Multiply Number Number Number : a -> b -> external "builtin" "multiply" a b

Divide : Left Right Quotient => trait (Left -> Right -> Quotient)
/ : multiplication operator (a b ~> Divide a b)
instance Divide Number Number Number : a -> b -> external "builtin" "divide" a b

Power : Left Right Power => trait (Left -> Right -> Power)
^ : power operator (a b ~> Power a b)
instance Power Number Number Number : a -> b -> external "builtin" "power" a b

-- Mutability --

mutable :: A => A -> Mutable A
mutable : x -> external "builtin" "make-mutable" x

get :: A => Mutable A -> A
get : m -> external "builtin" "get-mutable" m

set! :: A => A -> Mutable A -> ()
set! : x -> m -> external "builtin" "set-mutable" m x

swap! :: A => Mutable A -> Mutable A -> ()
swap! : a -> b -> external "builtin" "swap-mutable" a b
