[[no-std]]

[language "boolean"]
[help "Represents either `True` or `False`."]
[help-group "Logic"]
Boolean : type {
  False
  True
}

[help "Choose between two values depending on whether the input is `True` or `False`."]
[help-group "Control Flow"]
[keyword]
if : syntax {
  if 'bool 'then 'else -> when 'bool {
    True -> 'then
    False -> 'else
  }
  if 'bool 'then -> if 'bool 'then ()
}

[help "Represents the logical inverse of a value."]
[help-group "Logic"]
Not : (A : Boolean) => trait (A -> A)

instance (Not Boolean) : bool -> if bool False True
A B where (Not B) => instance (Not (A -> B)) : f x -> not (f x)

[help "Returns `False` if provided `True`, and vice versa. Can also be used on boolean functions and any other value that implements `Not`."]
[help-group "Logic"]
not :: A where (Not A) => A -> A
not : Not

And : Left Right (infer Output) => trait (Left -> (() -> Right) -> Output)

[help "Returns `True` if both sides are `True`."]
[help-group "Logic"]
[operator Conjunction-Precedence]
and : syntax {
  'a and 'b -> And 'a (() -> 'b)
  'a and -> And 'a
  and 'b -> a -> a and 'b
  and -> And
}

instance (And Boolean Boolean Boolean) : a? -> b? -> if a? (b? ()) False

Or : Left Right (infer Output) => trait (Left -> (() -> Right) -> Output)

[help "Returns `True` if either side is `True`."]
[help-group "Logic"]
[operator Disjunction-Precedence]
or : syntax {
  'a or 'b -> Or 'a (() -> 'b)
  'a or -> Or 'a
  or 'b -> a -> a or 'b
  or -> Or
}

instance (Or Boolean Boolean Boolean) : a? -> b? -> if a? True (b? ())

[help "The result of a comparison between two values."]
[help-group "Logic"]
Ordering : type {
  Less
  Equal
  Greater
}

[help "Implement this trait to enable comparisons between two values of your type."]
[help-group "Logic"]
Order : A => trait (A -> A -> Ordering)

instance (Order Number) : a b -> intrinsic "number-ordering" a b
instance (Order Integer) : a b -> intrinsic "integer-ordering" a b
instance (Order Natural) : a b -> intrinsic "natural-ordering" a b
instance (Order Byte) : a b -> intrinsic "byte-ordering" a b
instance (Order Signed) : a b -> intrinsic "signed-ordering" a b
instance (Order Unsigned) : a b -> intrinsic "unsigned-ordering" a b
instance (Order Float) : a b -> intrinsic "float-ordering" a b
instance (Order Double) : a b -> intrinsic "double-ordering" a b

[help "Returns `True` if the left side is less than the right side."]
[help-group "Logic"]
[operator Comparison-Precedence]
< : syntax {
  'a < 'b -> when (Order 'a 'b) {
    Ordering Less -> True
    Ordering Equal -> False
    Ordering Greater -> False
  }
  'a < -> {
    a : 'a
    b -> a < b
  }
  < 'b -> {
    b : 'b
    a -> a < b
  }
  < -> a b -> a < b
}

[help "Returns `True` if the left side is greater than the right side."]
[help-group "Logic"]
[operator Comparison-Precedence]
> : syntax {
  'a > 'b -> when (Order 'a 'b) {
    Ordering Less -> False
    Ordering Equal -> False
    Ordering Greater -> True
  }
  'a > -> {
    a : 'a
    b -> a > b
  }
  > 'b -> {
    b : 'b
    a -> a > b
  }
  > -> a b -> a > b
}

[help "Returns `True` if the left side is less than or equal to the right side."]
[help-group "Logic"]
[operator Comparison-Precedence]
<= : syntax {
  'a <= 'b -> when (Order 'a 'b) {
    Ordering Less -> True
    Ordering Equal -> True
    Ordering Greater -> False
  }
  'a <= -> {
    a : 'a
    b -> a <= b
  }
  <= 'b -> {
    b : 'b
    a -> a <= b
  }
  <= -> a b -> a <= b
}

[help "Returns `True` if the left side is greater than or equal to the right side."]
[help-group "Logic"]
[operator Comparison-Precedence]
>= : syntax {
  'a >= 'b -> when (Order 'a 'b) {
    Ordering Less -> False
    Ordering Equal -> True
    Ordering Greater -> True
  }
  'a >= -> {
    a : 'a
    b -> a >= b
  }
  >= 'b -> {
    b : 'b
    a -> a >= b
  }
  >= -> a b -> a >= b
}

[help "Implement this trait to enable equality testing between two values of your type."]
[help-group "Logic"]
Equal : A => trait (A -> A -> Boolean)

[help "Returns `True` if both sides are equal."]
[help-group "Logic"]
[operator Comparison-Precedence]
= : syntax {
  'a = 'b -> Equal 'a 'b
  'a = -> Equal 'a
  = 'b -> {
    b : 'b
    a -> a = b
  }
  = -> Equal
}

[help "Returns `True` if the left side is not equal to the right side."]
[help-group "Logic"]
[operator Comparison-Precedence]
/= : syntax {
  'a /= 'b -> not ('a = 'b)
  'a /= -> not Equal 'a
  /= 'b -> {
    b : 'b
    a -> a /= b
  }
  /= -> not Equal
}

instance (Equal Text) : a b -> intrinsic "text-equality" a b
instance (Equal Number) : a b -> intrinsic "number-equality" a b
instance (Equal Integer) : a b -> intrinsic "integer-equality" a b
instance (Equal Natural) : a b -> intrinsic "natural-equality" a b
instance (Equal Byte) : a b -> intrinsic "byte-equality" a b
instance (Equal Signed) : a b -> intrinsic "signed-equality" a b
instance (Equal Unsigned) : a b -> intrinsic "unsigned-equality" a b
instance (Equal Float) : a b -> intrinsic "float-equality" a b
instance (Equal Double) : a b -> intrinsic "double-equality" a b
instance (Equal ()) : () -> () -> True
instance (Equal Boolean) : a b -> if a b (not b)
