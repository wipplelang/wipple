---
next:
  name: Advanced functions
  link: ?lesson=advanced/functions
---

---
id: A4eVInXV
type: text
locked: true
---

# Type functions and traits

If you're familiar with other languages like JavaScript or Python, you might have noticed that Wipple lacks classes and methods. Wipple takes a different approach to defining a "blueprint" for a type's functionality, in the form of type functions and traits.

Have you noticed that `show` accepts text, numbers, Booleans, and so on? Normal functions can only accept an input of a single type, but `show` works a bit differently. Let's make another function called `my-show` that emulates the `show` function. `my-show` will use `show` under the hood so that we can see the output, but it will always convert its input to `Text` first.

We can start with the simplest form of `my-show` — just have it always accept `Text`:

---
id: RNRxL4ZP
type: code
---

my-show :: Text -> ()
my-show : text -> show text

---
id: 5tUdiIxi
type: text
locked: true
---

And yes, you can put the variable's type on its own line, right above the value! We'll be using this syntax from now on because we'll be writing more powerful functions that Wipple's type system will need a bit of help with.

Alright, now let's introduce a **type function**, which uses a double arrow `=>`:

---
id: n1mreYRl
type: code
---

my-show :: A => A -> ()
my-show : value -> show value

---
id: ZPTw56Yw
type: text
locked: true
---

Ignore the error for a second. In the same way a function introduces _some value_ into scope, a type function introduces _some type_ into scope. The `A` is a **type parameter**!

For now, let's just pretend that `show` only accepts `Text` as its input (since we know that will make the error go away), so we need to convert the `A` value into `Text` somehow. Let's use `where` to add a **bound** to our type function!

---
id: l0gb-uUv
type: code
---

my-show :: A where (My-Show A) => A -> ()
my-show : value -> show (My-Show value)

---
id: FX6dndju
type: text
locked: true
---

Now let's define `My-Show`!

---
id: Wh5x5w-k
type: code
---

My-Show : A => trait (A -> Text)

---
id: 8rCSr-eY
type: text
locked: true
---

The `trait` function accepts a type and produces a **trait**, which is in this case defined to hold a function that converts from _some type_ `A` to `Text`. Then, we can call the function implemented by `My-Show` inside `my-show` to get a `Text` value, which we finally pass to `show`.

Next, we need to implement that `My-Show` function for various types!

---
id: gVkvFKtJ
type: code
---

My-Show : A => trait (A -> Text)

instance (My-Show Text) : text -> text

instance (My-Show Boolean) : bool -> when bool {
  True -> "True"
  False -> "False"
}

---
id: A9vzvC-W
type: text
locked: true
---

The `instance` syntax goes on the left-hand side of a variable assignment `:`. It works by generating a new, unnamed variable and adding it to the list of available instances for the specified trait. So, whenever `My-Show` is called with a `Boolean`, that `instance` variable will be used.

Let's put it all together!

---
id: AvLGQu_E
type: code
---

My-Show : A => trait (A -> Text)

instance (My-Show Text) : text -> text

instance (My-Show Boolean) : bool -> when bool {
  True -> "True"
  False -> "False"
}

my-show :: A where (My-Show A) => A -> ()
my-show : value -> show (My-Show value)

my-show "Hello, world!"
my-show True

---
id: 5R6Wx40r
type: text
locked: true
---

Awesome! Now that you know how `My-Show` works, we can extend the idea to the regular `show` function, which, in fact, uses the `Show` trait!

---
id: mMENxugD
type: code
---

Sport : type {
  name :: Text
  players :: Number
}

instance (Show Sport) : sport -> "_ has _ players per team" (name of sport) (players of sport)

basketball : Sport {
  name : "Basketball"
  players : 5
}

show basketball

---
id: CjQ_KB1d
type: text
locked: true
---

As you can hopefully see, Wipple's traits are very powerful. They let you define new functionality for existing functions like `show`! Wipple uses traits extensively, from `Add` for addition using `+`, to `Equal` for equality using `=`, to `Show` for displaying something on the screen using `show`.

Traits in Wipple are so powerful that you can write entire programs using nothing but types and traits, all done at compile time. If you're interested in how that works, check out the accompanying Expert lesson!
