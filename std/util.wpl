[[no-std]]

use "fp"
use "logic"

[help "Retrieve a field from a structure value without introducing a new variable into scope."]
[help-group "Utilities"]
[help-playground "https://wipple.dev/std/examples/of.txt"]
[operator Accessor-Precedence]
of : syntax {
  'field of 'value -> {
    { 'field } : 'value
    'field
  }
}

[help "Crash the program with the provided message."]
[help-group "Utilities"]
crash :: (A : ()) => Text -> A
crash : message -> intrinsic "crash" message

[help "Indicates unfinished code. Crashes the program upon evaluation."]
[help-group "Utilities"]
... :: (A : ()) => A
... : crash "not yet implemented"

[help "Represents the presence or absence of a value."]
[help-group "Utilities"]
[on-mismatch Value "try handling the case where the `Maybe` is `None`, eg. using `when`, `try` or `expect`"]
[convert-from Value (Some 'value)]
Maybe : Value => type {
  None
  Some Value
}

[help "Represents the success or failure of an operation."]
[help-group "Utilities"]
[on-mismatch Success "try handling the case where the `Result` is `Error`, eg. using `when`, `try` or `expect`"]
[on-mismatch Failure "try converting the error to the correct type, eg. using `as` or `try`"]
[convert-from Success (Ok 'value)]
[convert-from Failure (Error 'value)]
Result : Success Failure => type {
  Ok Success
  Error Failure
}

[help "Implement this trait to enable usage of your type in error handling."]
[help-group "Utilities"]
Try : Value Success Failure => trait (Value -> Result Success Failure)

[help "Represents the failure to find a value inside a `Maybe`."]
[help-group "Utilities"]
None-Error : type

Expect : Container Value => trait (Text -> Container -> Value)

Value => instance (Expect (Maybe Value) Value) : message -> x? -> when x? {
  Some x -> x
  None -> crash message
}

Unwrap-Message : Container => trait (Container -> Text)

Value => instance (Unwrap-Message (Maybe Value)) : just "called `unwrap` on `None`"

Success Failure => instance (Unwrap-Message (Result Success Failure)) : just "called `unwrap` on `Error`"

[help "Produces the `Some` value contained within a `Maybe`, or crashes the program with the provided message."]
[help-group "Utilities"]
expect :: Container Value where (Expect Container Value) => Text -> Container -> Value
expect : Expect

[help "Produces the `Some` value contained within a `Maybe`, or crashes the program."]
[help-group "Utilities"]
unwrap :: Container Value where (Expect Container Value) (Unwrap-Message Container) => Container -> Value
unwrap : x? -> expect (Unwrap-Message x?) x?

As : Input Output => trait (Input -> Output)

[help "Convert a value of one type into a value of a different type."]
[help-group "Utilities"]
[operator Casting-Precedence]
as : syntax { 'x as 't -> (As 'x :: 't) }

A => instance (As A A) : it
instance (As Natural Number) : n -> intrinsic "natural-to-number" n
instance (As Natural Integer) : n -> intrinsic "natural-to-integer" n
Success => instance (As (Result Success _) (Maybe Success)) : result -> when result {
  Ok x -> Some x
  Error _ -> None
}

As? : Input Output => trait (Input -> Maybe Output)

[help "Convert a value of one type into a value of a different type, or `None` if the conversion fails."]
[help-group "Utilities"]
[operator Casting-Precedence]
as? : syntax { 'x as? 't -> (As? 'x :: Maybe 't) }

A => instance (As? A A) : Some
instance (As? Number Natural) : n -> intrinsic "number-to-natural" n
instance (As? Integer Natural) : n -> intrinsic "integer-to-natural" n

[help "Convert a value of one type into a value of a different type, or crash if the conversion fails."]
[help-group "Utilities"]
[operator Casting-Precedence]
as! : syntax { 'x as! 't -> 'x as? 't . expect "conversion failed" }

[help "Represents the default or initial value of a type."]
[help-group "Utilities"]
Default : A => trait A
instance (Default Number) : 0
instance (Default Text) : ""
instance (Default Boolean) : False
A => instance (Default (Maybe A)) : None

[help "Returns `True` if the value on the left side matches the pattern on the right side."]
[help-group "Utilities"]
[help-playground "https://wipple.dev/std/examples/is.txt"]
[operator Composition-Precedence]
is : syntax {
  'value is 'pattern -> when 'value {
    'pattern -> True
    _ -> False
  }
}
