[[no-implicit-use]]

use "fp"

[language "boolean"]
[help "Represents either `True` or `False`."]
[help-group "Logic"]
Boolean : type {
  False
  True
}

[help "Choose between two values depending on whether the input is `True` or `False`."]
[help-group "Control Flow"]
[keyword]
if : syntax {
  if 'bool 'then 'else -> when 'bool {
    True -> 'then
    False -> 'else
  }
  if 'bool 'then -> if 'bool 'then ()
}

[help "Represents the logical inverse of a value."]
[help-group "Logic"]
Not : A => trait (A -> A)

instance (Not Boolean) : bool -> if bool False True
A (B : Boolean) where (Not B) => instance (Not (A -> B)) : f -> f | not

[help "Returns `False` if provided `True`, and vice versa. Can also be used on boolean functions and any other value that implements `Not`."]
[help-group "Logic"]
not :: (A : Boolean) where (Not A) => A -> A
not : Not

And : Left Right Output => trait ((() -> Right) -> Left -> Output)

[private]
and' :: Left Right (infer Output) where (And Left Right Output) => ((() -> Right) -> Left -> Output)
and' : And

[help "Returns `True` if both sides are `True`."]
[help-group "Logic"]
[operator Conjunction-Precedence]
and : syntax {
  ('a and 'b) -> and' (() -> 'b) 'a
  ('a and) -> b -> and' b 'a
  (and 'b) -> and' (() -> 'b)
  (and) -> and'
}

instance (And Boolean Boolean Boolean) : b a -> if a (b ()) False

Or : Left Right Output => trait ((() -> Right) -> Left -> Output)

[private]
or' :: Left Right (infer Output) where (Or Left Right Output) => ((() -> Right) -> Left -> Output)
or' : Or

[help "Returns `True` if either side is `True`."]
[help-group "Logic"]
[operator Disjunction-Precedence]
or : syntax {
  ('a or 'b) -> or' (() -> 'b) 'a
  ('a or) -> b -> or' b 'a
  (or 'b) -> or' (() -> 'b)
  (or) -> or'
}

instance (Or Boolean Boolean Boolean) : b a -> if a True (b ())

[help "The result of a comparison between two values."]
[help-group "Logic"]
Ordering : type {
  Less
  Equal
  Greater
}

[help "Implement this trait to enable comparisons between two values of your type."]
[help-group "Logic"]
[on-unimplemented ("cannot compare _ values" A)]
Order : A => trait (A -> A -> Ordering)

instance (Order Number) : b a -> semantics "pure" (intrinsic "number-ordering" a b)
instance (Order Integer) : b a -> semantics "pure" (intrinsic "integer-ordering" a b)
instance (Order Natural) : b a -> semantics "pure" (intrinsic "natural-ordering" a b)
instance (Order Byte) : b a -> semantics "pure" (intrinsic "byte-ordering" a b)
instance (Order Signed) : b a -> semantics "pure" (intrinsic "signed-ordering" a b)
instance (Order Unsigned) : b a -> semantics "pure" (intrinsic "unsigned-ordering" a b)
instance (Order Float) : b a -> semantics "pure" (intrinsic "float-ordering" a b)
instance (Order Double) : b a -> semantics "pure" (intrinsic "double-ordering" a b)

[help "Returns `True` if the left side is less than the right side."]
[help-group "Logic"]
[operator Comparison-Precedence]
< : syntax {
  ('a < 'b) -> when (Order 'b 'a) {
    Ordering Less -> True
    Ordering Equal -> False
    Ordering Greater -> False
  }
  ('a <) -> {
    a : 'a
    b -> a < b
  }
  (< 'b) -> {
    b : 'b
    a -> a < b
  }
  (<) -> b a -> a < b
}

[help "Returns `True` if the left side is greater than the right side."]
[help-group "Logic"]
[operator Comparison-Precedence]
> : syntax {
  ('a > 'b) -> when (Order 'b 'a) {
    Ordering Less -> False
    Ordering Equal -> False
    Ordering Greater -> True
  }
  ('a >) -> {
    a : 'a
    b -> a > b
  }
  (> 'b) -> {
    b : 'b
    a -> a > b
  }
  (>) -> b a -> a > b
}

[help "Returns `True` if the left side is less than or equal to the right side."]
[help-group "Logic"]
[operator Comparison-Precedence]
<= : syntax {
  ('a <= 'b) -> when (Order 'b 'a) {
    Ordering Less -> True
    Ordering Equal -> True
    Ordering Greater -> False
  }
  ('a <=) -> {
    a : 'a
    b -> a <= b
  }
  (<= 'b) -> {
    b : 'b
    a -> a <= b
  }
  (<=) -> b a -> a <= b
}

[help "Returns `True` if the left side is greater than or equal to the right side."]
[help-group "Logic"]
[operator Comparison-Precedence]
>= : syntax {
  ('a >= 'b) -> when (Order 'b 'a) {
    Ordering Less -> False
    Ordering Equal -> True
    Ordering Greater -> True
  }
  ('a >=) -> {
    a : 'a
    b -> a >= b
  }
  (>= 'b) -> {
    b : 'b
    a -> a >= b
  }
  (>=) -> b a -> a >= b
}

[help "Implement this trait to enable equality testing between two values of your type."]
[help-group "Logic"]
[on-unimplemented ("cannot compare _ values" A)]
Equal : A => trait (A -> A -> Boolean)

[help "Returns `True` if both sides are equal."]
[help-group "Logic"]
[operator Comparison-Precedence]
= : syntax {
  ('a = 'b) -> Equal 'b 'a
  ('a =) -> {
    a : 'a
    b -> a = b
  }
  (= 'b) -> {
    b : 'b
    a -> a = b
  }
  (=) -> Equal
}

[help "Returns `True` if the left side is not equal to the right side."]
[help-group "Logic"]
[operator Comparison-Precedence]
/= : syntax {
  ('a /= 'b) -> not ('a = 'b)
  ('a /=) -> {
    a : 'a
    b -> a /= b
  }
  (/= 'b) -> {
    b : 'b
    a -> a /= b
  }
  (/=) -> b a -> not (Equal b a)
}

instance (Equal Text) : b a -> semantics "pure" (intrinsic "text-equality" a b)
instance (Equal Number) : b a -> semantics "pure" (intrinsic "number-equality" a b)
instance (Equal Integer) : b a -> semantics "pure" (intrinsic "integer-equality" a b)
instance (Equal Natural) : b a -> semantics "pure" (intrinsic "natural-equality" a b)
instance (Equal Byte) : b a -> semantics "pure" (intrinsic "byte-equality" a b)
instance (Equal Signed) : b a -> semantics "pure" (intrinsic "signed-equality" a b)
instance (Equal Unsigned) : b a -> semantics "pure" (intrinsic "unsigned-equality" a b)
instance (Equal Float) : b a -> semantics "pure" (intrinsic "float-equality" a b)
instance (Equal Double) : b a -> semantics "pure" (intrinsic "double-equality" a b)
instance (Equal ()) : () () -> True
instance (Equal Boolean) : b a -> if a b (not b)

[help "Returns the larger of the two inputs."]
[help-group "Logic"]
max :: A where (Order A) => A -> A -> A
max : a b -> if (a >= b) a b

[help "Returns the smaller of the two inputs."]
[help-group "Logic"]
min :: A where (Order A) => A -> A -> A
min : a b -> if (a <= b) a b
