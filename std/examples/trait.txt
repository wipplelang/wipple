---
id: LWk55dSG
type: text
locked: true
---

# How to use `trait`, `instance` and `where`

In Wipple, a trait represents a polymorphic value; in other words, the value of a trait depends on its type. `trait` is used in conjunction with the type function operator `=>` to define a trait:

---
id: dC1X0sTm
type: code
---

[help "Defines a way to convert a value into text."]
Show : A => trait (A -> Text)

---
id: dSru36W_
type: text
locked: true
---

In order to use `Show`, you have to define what its value should be when `A` takes a certain type. You can do this using an `instance` pattern:

---
id: 9R03qy9T
type: code
---

Foo : type
instance (Show Foo) : just "Foo"

---
id: gGDA4Yap
type: text
locked: true
---

`instance` works by creating a new, unnamed constant and associating its value with the usage of `Show` where `A` is `Foo`; that is, when `Show`'s type is `Foo -> Text`.

You can't have multiple instances with the same types:

---
id: xqtbeRAh
type: code
---

Foo : type
instance (Show Foo) : ...
instance (Show Foo) : ...

---
id: U3UDwKMG
type: text
locked: true
---

When there is an instance of a trait for a particular type(s), we say that the type(s) "implement" the trait.

Traits are typically used alongside generic constants as a form of dependency injection — for example, `Show` handles converting a value into text, and the related function `show` handles displaying that text on the screen.

Inside a generic constant, a type parameter is not assumed to implement any particular trait (even if the type the type parameter resolves to at the use site does indeed implement a certain trait). To allow the constant to assume that an instance involving a type parameter exists, you can add a bound using `where`:

---
id: PQ5oNL8L
type: code
---

show :: A where (Show A) => A -> ()
show : ...

---
id: lPrsTy71
type: text
locked: true
---

Now inside `show`, any use of `Show` whose type is `A -> Text` is valid, and it's up to the caller of `show` to ensure that the type `A` refers to actually implements `Show`.
