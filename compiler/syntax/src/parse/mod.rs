//! Parse a token tree into an abstract syntax tree.

mod base;
mod render;
mod rules;

pub use rules::*;

use crate::{
    tokenize::{Keyword, NonAssociativeOperator, Operator, TokenTree},
    Driver, Location,
};
use derivative::Derivative;
use serde::{Deserialize, Serialize};
use std::{fmt::Debug, hash::Hash};
use wipple_util::WithInfo;

/// A diagnostic generated by the parser.
#[derive(Derivative, Serialize, Deserialize)]
#[derivative(
    Debug(bound = ""),
    Clone(bound = ""),
    PartialEq(bound = "D::Info: PartialEq"),
    Eq(bound = "D::Info: Eq"),
    Hash(bound = "D::Info: Hash")
)]
pub struct Diagnostic<D: Driver> {
    /// The expected piece of syntax at this location.
    pub expected: SyntaxKind,

    /// Whether the diagnostic refers to the token before or after the expected
    /// syntax.
    pub direction: Option<Direction>,

    /// The syntax rules matched so far.
    pub stack: Vec<WithInfo<D::Info, SyntaxKind>>,
}

/// Whether a [`Diagnostic`] refers to the token before of after the expected
/// syntax.
#[allow(missing_docs)]
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub enum Direction {
    Before(SyntaxKind),
    After(SyntaxKind),
}

#[allow(missing_docs)]
#[derive(Debug, Clone, PartialEq, Eq, Hash, strum::Display, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
#[strum(serialize_all = "kebab-case")]
pub enum SyntaxKind {
    TopLevel,
    Attribute,
    AttributeValue,
    Name,
    Number,
    Text,
    Statement,
    LeftParenthesis,
    LeftBrace,
    Keyword(Keyword),
    ContextualKeyword(String),
    Operator(Operator),
    NonAssociativeOperator(NonAssociativeOperator),
    Instance,
    TypeParameter,
    Pattern,
    WildcardPattern,
    NumberPattern,
    TextPattern,
    VariantPattern,
    DestructurePattern,
    TuplePattern,
    OrPattern,
    MutatePattern,
    AnnotatePattern,
    Expression,
    Type,
    PlaceholderType,
    DeclaredType,
    FunctionType,
    TupleType,
    BlockType,
    IntrinsicType,
    MessageType,
    EqualType,
    TypeMember,
    FieldDeclaration,
    VariantDeclaration,
    Arm,
    TypeFunction,
    TypeRepresentation,
    SyntaxDeclaration,
    TypeDeclaration,
    TraitDeclaration,
    InstanceDeclaration,
    ConstantDeclaration,
    LanguageDeclaration,
    Assignment,
    AnnotateExpression,
    NameExpression,
    NumberExpression,
    TextExpression,
    DoExpression,
    CallExpression,
    ApplyExpression,
    BinaryOperatorExpression,
    AsExpression,
    IsExpression,
    WhenExpression,
    IntrinsicExpression,
    TupleExpression,
    CollectionExpression,
    StructureExpression,
    StructureField,
    WhenBody,
    WhenArm,
    BlockExpression,
    FunctionExpression,
    FunctionInputs,
    Nothing,
}

#[allow(missing_docs)]
#[derive(Debug)]
pub struct Result<D: Driver, T> {
    pub parsed: WithInfo<D::Info, T>,
    pub diagnostics: Vec<WithInfo<D::Info, Diagnostic<D>>>,
}

/// Parse a token tree into a concrete top-level syntax tree.
pub fn parse_top_level<D: Driver>(
    driver: &D,
    tree: WithInfo<D::Info, &TokenTree<'_, D>>,
) -> Result<D, TopLevel<D>>
where
    D::Info: From<Location>,
{
    parse_rule(driver, tree, rules::top_level())
}
