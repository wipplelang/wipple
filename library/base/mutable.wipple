[Create a shared reference to a value.]
reference :: Value => Value -> Reference Value
reference : value -> semantics "pure" (intrinsic "make-reference" value)

[Retrieve the value inside a reference.]
get-reference :: Value => Reference Value -> Value
get-reference : reference -> intrinsic "get-reference" reference

[Update the value inside a reference.]
set-reference :: Value => Value -> Reference Value -> Value
set-reference : value reference -> intrinsic "set-reference" reference value

[A container for a value that can change.]
Mutable : Value => type (
    Constant Value
    Referred (Reference Value)
    Binding (lazy Value) (Value -> ())
)

[Create a new mutable value.]
mutable :: Value => Value -> Mutable Value
mutable : value -> Referred (reference value)

[Create a new mutable value that ignores changes.]
constant :: Value => Value -> Mutable Value
constant : value -> Constant value

[Create a new mutable value that computes its value each time it is accessed.]
binding :: Value => lazy Value -> (Value -> ()) -> Mutable Value
binding : Binding

[Project a mutable value to refer to a component of the value.]
project :: A B => (A -> B) -> (B -> A -> A) -> Mutable A -> Mutable B
project : inner outer mutable ->
    Binding (inner (get mutable)) (new -> mutable . set! (get mutable . outer value))

[Perform an action when a mutable value changes.]
inspect :: Value => (Value -> ()) -> Mutable Value -> Mutable Value
inspect : action -> project it (new _ -> (
    action new
    new
))

[Retrieve the value contained inside a mutable value.]
get :: Value => Mutable Value -> Value
get : mutable -> when mutable (
    Constant value -> value
    Referred reference -> get-reference reference
    Binding value _ -> evaluate value
)

[Update the value contained inside a mutable value.]
set! :: Value => Value -> Mutable Value -> ()
set! : value mutable -> when mutable (
    Constant _ -> ()
    Referred reference -> reference . set-reference value
    Binding _ update -> update value
)

[Swap the contents of two mutable values.]
swap! :: Value => Mutable Value -> Mutable Value -> ()
swap! : b a -> (
    temp : get a
    a . set! (get b)
    b . set! temp
)

[Toggle a mutable boolean value.]
toggle! :: Value where (Not Value) => Mutable Value -> ()
toggle! : boolean -> boolean . set! (not (get boolean))

[Add a number to a mutable number.]
add! :: Left Right where (Add Left Right Left) => Right -> Mutable Left -> ()
add! : n m -> m . set! (get m + n)

[Increment a mutable number by one.]
increment! :: Value where (Add Value Number Value) => Mutable Value -> ()
increment! : add! 1

[Remove the value contained inside a mutable value, replacing it with `Default`.]
take! :: Value where (Default Value) => Mutable Value -> Value
take! : mutable -> (
    value : get mutable
    mutable . set! Default
    value
)
