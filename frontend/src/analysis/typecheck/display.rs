use crate::FieldIndex;

use super::{
    Arm, Expression, ExpressionKind, Pattern, PatternKind, Program, Type, TypeAnnotation,
    TypeAnnotationKind, TypeDeclKind, TypeStructure,
};
use std::fmt;

impl fmt::Display for Program {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(
            f,
            "-- This file was generated by the Wipple compiler for debugging purposes."
        )?;
        writeln!(f)?;

        for item in self.items.values() {
            let item = item.read();
            let (constant, expr) = &*item;

            if let Some((tr, constant)) = constant {
                if let Some(tr) = tr {
                    let decl = self
                        .declarations
                        .instances
                        .get(tr)
                        .unwrap()
                        .get(constant)
                        .unwrap();

                    let trait_name = self
                        .declarations
                        .traits
                        .get(&decl.trait_id)
                        .map(|tr| tr.name.to_string())
                        .unwrap_or_else(|| format!("<unknown trait #{}>", decl.trait_id.counter));

                    write!(f, "instance ({trait_name}")?;

                    for ty in &decl.trait_param_annotations {
                        write!(f, " ")?;
                        ty.display_with(f, self)?;
                    }

                    write!(f, ")")?;

                    write!(f, " : ")?;
                    expr.display_with(f, self, 0)?;

                    writeln!(f)?;
                    writeln!(f)?;
                } else {
                    let decl = self.declarations.constants.get(constant).unwrap();

                    write!(f, "{} :: ", decl.name)?;
                    decl.ty_annotation.display_with(f, self)?;
                    writeln!(f)?;

                    write!(f, "{} : ", decl.name)?;
                    expr.display_with(f, self, 0)?;

                    writeln!(f)?;
                    writeln!(f)?;
                }
            } else {
                expr.display_with(f, self, 0)?;
            }
        }

        Ok(())
    }
}

impl Expression {
    fn display_with(&self, f: &mut impl fmt::Write, file: &Program, indent: usize) -> fmt::Result {
        match &self.kind {
            ExpressionKind::Error(_) => write!(f, "<error expression>")?,
            ExpressionKind::Marker => {
                let id = match self.ty {
                    Type::Named(id, _, _) => id,
                    _ => {
                        write!(f, "<unknown marker type>")?;
                        return Ok(());
                    }
                };

                let name = match file.declarations.types.get(&id) {
                    Some(decl) => decl.name,
                    None => {
                        write!(f, "<unknown marker type>")?;
                        return Ok(());
                    }
                };

                write!(f, "{name}")?;
            }
            ExpressionKind::Constant(item) | ExpressionKind::ExpandedConstant(item) => {
                match file.items.get(item) {
                    Some(item) => {
                        let item = item.read();
                        if let (Some((tr, id)), _) = *item {
                            if let Some(tr) = tr {
                                let name = file
                                    .declarations
                                    .traits
                                    .get(&tr)
                                    .map(|tr| tr.name.to_string())
                                    .unwrap_or_else(|| format!("<unknown trait #{}>", tr.counter));

                                write!(f, "{name}")?;
                            } else {
                                let name = file
                                    .declarations
                                    .constants
                                    .get(&id)
                                    .map(|constant| constant.name.to_string())
                                    .unwrap_or_else(|| {
                                        format!("<unknown constant #{}>", id.counter)
                                    });

                                write!(f, "{name}")?;
                            }
                        } else {
                            write!(f, "<unknown constant>")?;
                        }
                    }
                    _ => {
                        write!(f, "<unknown constant>")?;
                    }
                };
            }
            ExpressionKind::Variable(id) => {
                let name = file
                    .declarations
                    .variables
                    .get(id)
                    .and_then(|var| var.name.as_deref().map(ToString::to_string))
                    .unwrap_or_else(|| format!("<unknown variable #{}>", id.counter));

                write!(f, "{name}")?;
            }
            ExpressionKind::Text(value) => write!(f, "{value:?}")?,
            ExpressionKind::Number(value) => write!(f, "{value}")?,
            ExpressionKind::Integer(value) => write!(f, "{value}")?,
            ExpressionKind::Natural(value) => write!(f, "{value}")?,
            ExpressionKind::Byte(value) => write!(f, "{value}")?,
            ExpressionKind::Signed(value) => write!(f, "{value}")?,
            ExpressionKind::Unsigned(value) => write!(f, "{value}")?,
            ExpressionKind::Float(value) => write!(f, "{value}")?,
            ExpressionKind::Double(value) => write!(f, "{value}")?,
            ExpressionKind::Block(exprs, _) => {
                writeln!(f, "{{")?;
                for expr in exprs {
                    write!(f, "{}", "\t".repeat(indent + 1))?;
                    expr.display_with(f, file, indent + 1)?;
                    writeln!(f)?;
                }
                write!(f, "{}}}", "\t".repeat(indent))?;
            }
            ExpressionKind::Call(func, input, _) => {
                write!(f, "(")?;
                func.display_with(f, file, indent)?;
                write!(f, " ")?;
                input.display_with(f, file, indent)?;
                write!(f, ")")?;
            }
            ExpressionKind::Function(pattern, value, _) => {
                let input_ty = match &self.ty {
                    Type::Function(input, _) => input,
                    _ => {
                        write!(f, "<unknown function>")?;
                        return Ok(());
                    }
                };

                write!(f, "(")?;
                pattern.display_with(f, input_ty, file, indent)?;
                write!(f, " -> ")?;
                value.display_with(f, file, indent)?;
                write!(f, ")")?;
            }
            ExpressionKind::When(expr, arms) => {
                let input_ty = &expr.ty;

                write!(f, "(when ")?;
                expr.display_with(f, file, indent)?;
                writeln!(f, " {{")?;
                for arm in arms {
                    write!(f, "{}", "\t".repeat(indent + 1))?;
                    arm.display_with(f, input_ty, file, indent + 1)?;
                    writeln!(f)?;
                }
                write!(f, "{}}})", "\t".repeat(indent))?;
            }
            ExpressionKind::External(namespace, identifier, inputs) => {
                write!(f, "(external {namespace:?} {identifier:?}")?;
                for expr in inputs {
                    write!(f, " ")?;
                    expr.display_with(f, file, indent)?;
                }
                write!(f, ")")?;
            }
            ExpressionKind::Runtime(func, inputs) => {
                write!(f, "(external {:?} {:?}", "runtime", func.to_string())?;
                for expr in inputs {
                    write!(f, " ")?;
                    expr.display_with(f, file, indent)?;
                }
                write!(f, ")")?;
            }
            ExpressionKind::Initialize(pattern, value) => {
                pattern.display_with(f, &value.ty, file, indent)?;
                write!(f, " : ")?;
                value.display_with(f, file, indent)?;
            }
            ExpressionKind::Structure(fields) => {
                let id = match self.ty {
                    Type::Named(id, _, _) => id,
                    _ => {
                        write!(f, "<unknown structure type>")?;
                        return Ok(());
                    }
                };

                let ty = match file.declarations.types.get(&id) {
                    Some(ty) => ty,
                    None => {
                        write!(f, "<unknown structure type>")?;
                        return Ok(());
                    }
                };

                let name = ty.name;
                let field_names = match &ty.kind {
                    TypeDeclKind::Structure { field_names, .. } => field_names,
                    _ => {
                        write!(f, "<unknown structure type>")?;
                        return Ok(());
                    }
                };

                writeln!(f, "({name} {{")?;
                for (index, value) in fields.iter().enumerate() {
                    let name = field_names
                        .iter()
                        .find_map(|(name, i)| {
                            (*i == FieldIndex::new(index)).then_some(name.to_string())
                        })
                        .unwrap_or_else(|| format!("<unknown field #{index}>"));

                    write!(f, "{}{} : ", "\t".repeat(indent + 1), name)?;
                    value.display_with(f, file, indent + 1)?;
                    writeln!(f)?;
                }
                write!(f, "{}}})", "\t".repeat(indent))?;
            }
            ExpressionKind::Variant(index, values) => {
                let id = match self.ty {
                    Type::Named(id, _, _) => id,
                    _ => {
                        write!(f, "<unknown enumeration type>")?;
                        return Ok(());
                    }
                };

                let ty = match file.declarations.types.get(&id) {
                    Some(ty) => ty,
                    None => {
                        write!(f, "<unknown enumeration type>")?;
                        return Ok(());
                    }
                };

                let ty_name = ty.name;

                let variant_names = match &ty.kind {
                    TypeDeclKind::Enumeration { variant_names, .. } => variant_names,
                    _ => {
                        write!(f, "<unknown enumeration type>")?;
                        return Ok(());
                    }
                };

                let variant_name = variant_names
                    .iter()
                    .find_map(|(name, i)| (i == index).then_some(name.to_string()))
                    .unwrap_or_else(|| format!("<unknown variant #{}>", index.into_inner()));

                write!(f, "({ty_name} {variant_name}")?;
                for value in values {
                    write!(f, " ")?;
                    value.display_with(f, file, indent)?;
                }
                write!(f, ")")?;
            }
            ExpressionKind::Tuple(exprs) => {
                write!(f, "(")?;
                for (index, expr) in exprs.iter().enumerate() {
                    if index != 0 {
                        write!(f, " , ")?;
                    }

                    expr.display_with(f, file, indent)?;
                }
                write!(f, ")")?;
            }
            ExpressionKind::Format(segments, trailing_segment) => {
                write!(f, "(format")?;
                for (text, expr) in segments {
                    write!(f, " {:?} ", text.as_str())?;
                    expr.display_with(f, file, indent)?;
                }
                if let Some(text) = trailing_segment {
                    write!(f, " {text:?}")?;
                }
                write!(f, ")")?;
            }
            ExpressionKind::With((id, value), body) => {
                write!(f, "(with (")?;

                if let Some(id) = id {
                    let name = file
                        .declarations
                        .constants
                        .get(id)
                        .map(|constant| constant.name.to_string())
                        .unwrap_or_else(|| format!("<unknown constant #{}>", id.counter));

                    write!(f, "{name} : ")?;
                } else {
                    write!(f, "<unknown constant> : ")?;
                }

                value.display_with(f, file, indent)?;
                write!(f, ") ")?;

                body.display_with(f, file, indent)?;
                write!(f, ")")?;
            }
            ExpressionKind::ContextualConstant(id) => {
                let name = file
                    .declarations
                    .constants
                    .get(id)
                    .map(|constant| constant.name.to_string())
                    .unwrap_or_else(|| format!("<unknown constant #{}>", id.counter));

                write!(f, "{name}")?;
            }
            ExpressionKind::End(value) => {
                write!(f, "(end ")?;
                value.display_with(f, file, indent)?;
                write!(f, ")")?;
            }
        }

        Ok(())
    }
}

impl Arm {
    fn display_with(
        &self,
        f: &mut impl fmt::Write,
        input_ty: &Type,
        file: &Program,
        indent: usize,
    ) -> fmt::Result {
        self.pattern.display_with(f, input_ty, file, indent)?;
        if let Some(guard) = &self.guard {
            write!(f, " where ")?;
            guard.display_with(f, file, indent)?;
        }
        write!(f, " -> ")?;
        self.body.display_with(f, file, indent)?;
        Ok(())
    }
}

impl Pattern {
    fn display_with(
        &self,
        f: &mut impl fmt::Write,
        input_ty: &Type,
        file: &Program,
        indent: usize,
    ) -> fmt::Result {
        match &self.kind {
            PatternKind::Error(_) => write!(f, "<error pattern>")?,
            PatternKind::Wildcard => write!(f, "_")?,
            PatternKind::Text(value) => write!(f, "{value:?}")?,
            PatternKind::Number(value) => write!(f, "{value}")?,
            PatternKind::Integer(value) => write!(f, "{value}")?,
            PatternKind::Natural(value) => write!(f, "{value}")?,
            PatternKind::Byte(value) => write!(f, "{value}")?,
            PatternKind::Signed(value) => write!(f, "{value}")?,
            PatternKind::Unsigned(value) => write!(f, "{value}")?,
            PatternKind::Float(value) => write!(f, "{value}")?,
            PatternKind::Double(value) => write!(f, "{value}")?,
            PatternKind::Variable(id) => {
                let name = file
                    .declarations
                    .variables
                    .get(id)
                    .and_then(|decl| decl.name.as_deref().map(ToString::to_string))
                    .unwrap_or_else(|| format!("<unknown variable #{}>", id.counter));

                write!(f, "{name}")?;
            }
            PatternKind::Destructure(_, fields) => {
                let (id, field_tys) = match input_ty {
                    Type::Named(id, _, TypeStructure::Structure(fields)) => (id, fields),
                    _ => {
                        write!(f, "<unknown structure type>")?;
                        return Ok(());
                    }
                };

                let ty = match file.declarations.types.get(id) {
                    Some(ty) => ty,
                    None => {
                        write!(f, "<unknown structure type>")?;
                        return Ok(());
                    }
                };

                let field_names = match &ty.kind {
                    TypeDeclKind::Structure { field_names, .. } => field_names,
                    _ => {
                        write!(f, "<unknown structure type>")?;
                        return Ok(());
                    }
                };

                writeln!(f, "{{")?;
                for ((index, pattern), ty) in fields.iter().zip(field_tys) {
                    let name = field_names
                        .iter()
                        .find_map(|(name, i)| (i == index).then(|| name.to_string()))
                        .unwrap_or_else(|| format!("<unknown field #{}>", index.into_inner()));

                    write!(f, "{}{} : ", "\t".repeat(indent + 1), name)?;
                    pattern.display_with(f, ty, file, indent + 1)?;
                    writeln!(f)?;
                }
                write!(f, "{}}}", "\t".repeat(indent))?;
            }
            PatternKind::Variant(id, index, patterns) => {
                let variant_tys = match input_ty {
                    Type::Named(_, _, TypeStructure::Enumeration(variants)) => variants,
                    _ => {
                        write!(f, "<unknown enumeration type>")?;
                        return Ok(());
                    }
                };

                let ty = match file.declarations.types.get(id) {
                    Some(ty) => ty,
                    None => {
                        write!(f, "<unknown enumeration type>")?;
                        return Ok(());
                    }
                };

                let ty_name = ty.name;

                let variant_names = match &ty.kind {
                    TypeDeclKind::Enumeration { variant_names, .. } => variant_names,
                    _ => {
                        write!(f, "<unknown enumeration type>")?;
                        return Ok(());
                    }
                };

                let variant_name = variant_names
                    .iter()
                    .find_map(|(name, i)| (i == index).then_some(name.to_string()))
                    .unwrap_or_else(|| format!("<unknown variant #{}>", index.into_inner()));

                let value_tys = &variant_tys[index.into_inner()];

                write!(f, "({ty_name} {variant_name}")?;
                for (pattern, ty) in patterns.iter().zip(value_tys) {
                    write!(f, " ")?;
                    pattern.display_with(f, ty, file, indent)?;
                }
                write!(f, ")")?;
            }
            PatternKind::Or(left, right) => {
                write!(f, "(")?;
                left.display_with(f, input_ty, file, indent)?;
                write!(f, " or ")?;
                right.display_with(f, input_ty, file, indent)?;
                write!(f, ")")?;
            }
            PatternKind::Tuple(patterns) => {
                let value_tys = match input_ty {
                    Type::Tuple(tys) => tys,
                    _ => {
                        write!(f, "<unknown tuple pattern>")?;
                        return Ok(());
                    }
                };

                write!(f, "(")?;
                for ((index, pattern), ty) in patterns.iter().enumerate().zip(value_tys) {
                    if index != 0 {
                        write!(f, " , ")?;
                    }

                    pattern.display_with(f, ty, file, indent)?;
                }
                write!(f, ")")?;
            }
        }

        Ok(())
    }
}

impl TypeAnnotation {
    fn display_with(&self, f: &mut impl fmt::Write, file: &Program) -> fmt::Result {
        match &self.kind {
            TypeAnnotationKind::Error(_) => write!(f, "<error type>")?,
            TypeAnnotationKind::Placeholder => write!(f, "_")?,
            TypeAnnotationKind::Named(id, params) => {
                let name = match file.declarations.types.get(id) {
                    Some(ty) => ty.name,
                    None => {
                        write!(f, "<unknown named type>")?;
                        return Ok(());
                    }
                };

                write!(f, "({name}")?;
                for ty in params {
                    write!(f, " ")?;
                    ty.display_with(f, file)?;
                }
                write!(f, ")")?;
            }
            TypeAnnotationKind::Parameter(id) => {
                let name = file
                    .declarations
                    .type_parameters
                    .get(id)
                    .and_then(|decl| decl.name.as_deref().map(ToString::to_string))
                    .unwrap_or_else(|| format!("<unknown type parameter #{}>", id.counter));

                write!(f, "{name}")?;
            }
            TypeAnnotationKind::Builtin(id, params) => {
                let name = match file.declarations.builtin_types.get(id) {
                    Some(ty) => ty.name,
                    None => {
                        write!(f, "<unknown builtin type>")?;
                        return Ok(());
                    }
                };

                write!(f, "({name}")?;
                for ty in params {
                    write!(f, " ")?;
                    ty.display_with(f, file)?;
                }
                write!(f, ")")?;
            }
            TypeAnnotationKind::Function(input, output) => {
                write!(f, "(")?;
                input.display_with(f, file)?;
                write!(f, " -> ")?;
                output.display_with(f, file)?;
                write!(f, ")")?;
            }
            TypeAnnotationKind::Tuple(tys) => {
                write!(f, "(")?;
                for (index, ty) in tys.iter().enumerate() {
                    if index != 0 {
                        write!(f, " , ")?;
                    }

                    ty.display_with(f, file)?;
                }
                write!(f, ")")?;
            }
        }

        Ok(())
    }
}
