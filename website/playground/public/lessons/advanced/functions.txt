---
previous:
  name: Type functions and traits
  link: ?lesson=advanced/traits
next:
  name: Advanced patterns
  link: ?lesson=advanced/patterns
---

---
id: wzLqR7Iw
type: text
locked: true
---

# Advanced functions

Wipple is a **functional programming language**, which means that Wipple encourages creating and composing functions over other methods of programming, like class-based inheritance and mutable state. In this lesson, we'll learn how to write idiomatic, functional Wipple code.

## Partial application

Up until now, we've declared functions that accept multiple inputs like this:

---
id: OuA_Oq0i
type: code
---

add : a b -> a + b
show (add 1 2)

---
id: iPCc6H7Q
type: text
locked: true
---

But if you've looked at the type of `add`, you may have noticed that it's not `Number Number -> Number`, but `Number -> Number -> Number`! What's going on?

Well, it turns out that `a b -> a + b` is actually shorthand for `a -> b -> a + b`. Wipple functions actually only accept **one input at a time**, so `add 1 2` is the same as writing `(add 1) 2`. Essentially, the `add` function returns _another_ function!

There's nothing special about the function `add` returns, so we can assign it to a variable:

---
id: vaRaLlmh
type: code
---

add : a -> b -> a + b
increment : add 1
show (increment 2)

---
id: CMlIGTaV
type: text
locked: true
---

This idea of calling a function with only one input at a time is called **partial application**, and if used correctly, it can make your code much easier to read. It can take a while to really embrace partial application, but when you do, it just makes sense — _"increment is add one"_ is almost an English sentence!

In other languages, you might have a function `score` that sets the number of points a `Team` object has scored. But in functional languages like Wipple, you usually create a new, updated `Team` value instead of mutating the original:

---
id: CLL97pQ8
type: code
---

Team : type {
  points :: Number
}

score :: Team -> Number -> Team
score : team points-to-add -> Team {
  points : (points of team) + points-to-add
}

celtics : Team { points : 80 }
celtics : score celtics 2
show (points of celtics)

---
id: xU-N53hK
type: text
locked: true
---

This makes programs easier to reason about and debug, because you can always look back at the original value to see what has changed. It also means that changes are localized to wherever they are applied — you're always dealing with your own copy of a value instead of having to worry about changing a copy somewhere else in the program.

Also, notice how we redeclare the `celtics` variable after changing the number of points. Wipple allows you to reuse variable names if you don't need the original anymore. In this case, we only want to deal with the updated `celtics`, so we can overwrite that variable. If you want to learn more about how this works, check out the Expert lesson on scope!

OK, now let's say we want to add a `basket` function that increments the team's score by 2:

---
id: 5gRtfAbG
type: code
---

Team : type {
  points :: Number
}

score :: Team -> Number -> Team
score : team points-to-add -> Team {
  points : (points of team) + points-to-add
}

basket :: Team -> Team
basket : team -> score team 2

celtics : Team { points : 80 }
celtics : basket celtics
show (points of celtics)

---
id: hHBx9Iv9
type: text
locked: true
---

This code is probably how you'd do it in other languages, but watch what happens if we swap the order of `points-to-add` and `team`:

---
id: 3t_JDbj2
type: code
---

Team : type {
  points :: Number
}

score :: Number -> Team -> Team
score : points-to-add team -> Team {
  points : (points of team) + points-to-add
}

basket :: Team -> Team
basket : team -> score 2 team

celtics : Team { points : 80 }
celtics : basket celtics
show (points of celtics)

---
id: KhIL3gsq
type: text
locked: true
---

And now we can use partial application to simplify `birthday`!

---
id: TICqE1rc
type: code
---

Team : type {
  points :: Number
}

score :: Number -> Team -> Team
score : points-to-add team -> Team {
  points : (points of team) + points-to-add
}

basket :: Team -> Team
basket : score 2

celtics : Team { points : 80 }
celtics : basket celtics
show (points of celtics)

---
id: ARgdOFWr
type: text
locked: true
---

Much nicer — all of the above examples produce the same output! Now `basket` doesn't have to deal with passing a `Team` around, it can just focus on what it's really trying to do — increment the score by 2. In general, any time you see `x -> f x`, you can replace it with `f`.

## Dot syntax

Dot syntax allows you to provide the input to the left of the function, so you can chain function calls:

---
id: KM4sSH3J
type: code
---

add : a b -> a + b
0 . add 1 . add 2 . add 3 . show

---
id: FN9RhVdo
type: text
locked: true
---

## Higher-order functions

`times` is what's called a **higher-order function** because it accepts a function as input. There's nothing special about doing this, you just call the function as normal! For example:

---
id: HURTDKpF
type: code
---

call-with : f x -> f x
4 . call-with show

---
id: UxXlITw8
type: text
locked: true
---

You don't even need a type signature here — Wipple figures out what you're trying to do and gives `f` the type `Number -> ()`!

We can also make `call-with` generic over the input and output types using a type function:

---
id: 9qTyI45t
type: code
---

call-with :: Input Output => (Input -> Output) -> Input -> Output
call-with : f x -> f x

increment :: Number -> Number
increment : x -> x + 1

4 . call-with increment . call-with show

---
id: 762fQwaw
type: text
locked: true
---

And of course, that's just equivalent to writing:

---
id: 4RZsgU4P
type: code
---

increment :: Number -> Number
increment : x -> x + 1

4 . increment . show

---
id: iMtpIi79
type: text
locked: true
---

Now you know how function calling is implemented!
