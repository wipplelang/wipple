---
page: Scope
type: text
locked: true
---

In this lesson, we'll take a look at how Wipple organizes variables using **scope**. In Wipple, variable assignment using `:` is actually shorthand for using `when`:

---
page: Scope
type: code
---

-- This:
x : 42
show x

-- Is equivalent to:
when 42 {
    x -> show x
}

---
page: Scope
type: text
locked: true
---

As a consequence, you can only access a variable inside the block in which it was defined (and all sub-blocks). If you declare multiple variables inside a single block, the variables are defined top to bottom. Here's another example:

---
page: Scope
type: code
---

-- This:
a : 1
b : 2
sum : a + b
show sum

-- Is equivalent to:
when 1 {
    a -> when 2 {
        b -> when (a + b) {
            sum -> show sum
        }
    }
}

---
page: Scope
type: text
locked: true
---

## Shadowing

Although you can't change a variable after you define it, Wipple allows you to reuse, or **shadow** variable names. The new variable is completely different from the old variable and doesn't need to have the same type — you just can't access the original variable in that scope anymore.

---
page: Scope
type: code
---

number : 1
number : number + 1
show number

---
page: Scope
type: text
locked: true
---

In the above example, you might as well pretend that the variable is being reassigned. But watch what happens when we capture the variable in a function before redeclaring it:

---
page: Scope
type: code
lint: true
---

number : 1
show-number : () -> show number
number : number + 1
show-number ()

---
page: Scope
type: text
locked: true
---

`show-number` always refers to the `number` declared before `show-number` itself was declared. In fact, Wipple even tells us that the second `number` is never used!

If you really need to be able to change `number`'s value and have it be observed everywhere, you can use `mutable` — see the Advanced lesson on mutability for more details!

## Instances

The only kind of variable you can't shadow is a variable created by `instance`. You can only refer to `instance`s through the use of a trait, and Wipple doesn't normally allow you to have two instances that share the same type:

---
page: Scope
type: code
---

X : type

instance (Show X) : _ -> "instance 1"
instance (Show X) : _ -> "instance 2"

---
page: Scope
type: text
locked: true
---

If you really need overlapping instances, you can put the `[sealed]` and `[allow-overlapping-instances]` **attributes** on your trait. This tells Wipple to disable checking for conflicts and just use the first instance that matches. We'll talk about attributes more in the next lesson.

---
page: Scope
type: code
---

X : type

[sealed]
[allow-overlapping-instances]
My-Show : A => trait (A -> Text)

instance (My-Show X) : _ -> "instance 1"
instance (My-Show X) : _ -> "instance 2"

show (My-Show X)

---
page: Scope
type: text
locked: true
---

You normally don't need to use `allow-overlapping-instances`, but if you're writing extremely generic code with assumptions you can't fully encode as types, Wipple's type system might get confused. We'll see an example where `allow-overlapping-instances` is necessary in an upcoming lesson!


---
page: Attributes
type: text
locked: true
---

Each one of Wipple's constructs (types, traits, constants, instances, etc.) have their own default behavior. But sometimes you need to express something more complicated that overrides this behavior. Wipple offers several **attributes** that allow you to do this!

Attributes are written in square brackets (`[` and `]`) above a declaration. For example, the `help` attribute allows you to write documentation for your function:

---
page: Attributes
type: code
---

[help "Adds two numbers together."]
add :: Number -> Number -> Number
add : a b -> a + b

---
page: Attributes
type: text
locked: true
---

In the above code box, click on the + symbol on the right and scroll down, and you'll find your `add` function listed! You can use the `help-group` attribute to assign `add` to a particular category in the list.

Another useful attribute is `on-unimplemented`, which lets you customize the error message when Wipple can't find an instance for a trait:

---
page: Attributes
type: code
---

Carnivore : type
Herbivore : type
Omnivore : type

Animals : type
Plants : type

[on-unimplemented ("_ does not eat _" Animal Food)]
Eat : Animal Food => trait (Animal ; Food)

instance (Eat Carnivore Animals) : ...
instance (Eat Herbivore Plants) : ...
instance (Eat Omnivore Animals) : ...
instance (Eat Omnivore Plants) : ...

(Eat) :: Carnivore ; Plants

---
page: Attributes
type: text
locked: true
---

We'll learn another attribute, `specialize`, in the next lesson!


---
page: Specialization
type: text
locked: true
---

We haven't talked a lot about performance, but Wipple has a construct that can eliminate unnecessary work in some cases! Let's create a `Counter` sequence:

---
page: Specialization
type: code
---

Counter : type {
    count :: Mutable Natural
    max :: Natural
}

instance (As-Sequence Counter Natural) : { count max } -> {
    sequence {
        n : get count
        if (n = max) {
            None
        } {
            increment! count
            Some n
        }
    }
}

count-up-to :: Natural -> Counter
count-up-to : max -> Counter {
    count : mutable 0
    max
}

show (count (count-up-to 10))

---
page: Specialization
type: text
locked: true
---

The built-in `count` function takes a sequence and counts how many items there are in the sequence. It essentially works by incrementing a `Mutable Natural` for `each` time the sequence produces a new value. But our custom `Counter` sequence already knows its `count`, so iterating through each item is a lot of extra work! In computer science lingo, we can theoretically reduce `count`'s time complexity from $O(n)$ to $O(1)$.

Unfortunately, we can't change the `count` function because it's built in to Wipple. But since `count` is generic, what we can do is **specialize** it using the `[specialize]` attribute!

---
page: Specialization
type: code
---

Counter : type {
    max :: Natural -- we only care about `max` in this example
}

instance (As-Sequence Counter Natural) : ...

[specialize]
count :: Counter -> Natural
count : { max } -> max

---
page: Specialization
type: text
locked: true
---

Now, _any_ Wipple code that calls `count` will use our specialized implementation. Thus, it's super important that the specialized `count` has exactly the same behavior as the original `count`. Only specialize constants for types that you created (Wipple may enforce this in the future).

In general, you don't need to worry about specialization — computers are pretty fast nowadays! Did you know that the entire Wipple compiler is running inside this browser tab? That's right, everything is run locally on your computer!

Let's next turn our attention to one of Wipple's most powerful features: **custom syntax**!


---
page: Domain-specific languages
type: text
locked: true
---

It's time to learn how Wipple really works under the hood and harness its power to build your own **domain-specific languages** (DSLs). Many of the "functions" we've discussed, like `if`, are actually defined as custom syntax! But before we learn how to make our own syntax, let's take a look at one more concept: **context**.

Have you ever wondered why we need `with-turtle`, `with-music`, `with-graph`, and so on? The high-level answer is that Wipple needs to know _which_ turtle or instrument or graph to use. But functions like `forward` and `note` and `plot` don't accept `Turtle` or `Music` or `Graph` values!

In these cases, Wipple allows you to _break the rules of scope_ and introduce a **contextual constant**. The value of a contextual constant _can_ be changed dynamically throughout the program, using a `with` expression. Let's build our own DSL that controls a virtual robot!

---
page: Domain-specific languages
type: code
---

Robot : type {
    name :: Text
}

[context]
robot :: Robot
robot : error "`robot` not initialized"

---
page: Domain-specific languages
type: text
locked: true
---

The `[context]` attribute creates a contextual constant. You can define a default value for the constant — in this case, we crash the program if the `robot`'s value isn't overwritten. Otherwise, you use `robot` as normal.

Now, we can use the `with` expression to overwrite the `robot`'s value!

---
page: Domain-specific languages
type: code
---

Robot : type {
    name :: Text
}

[context]
robot :: Robot
robot : error "`robot` not initialized"

with (robot : Robot { name : "Bot" }) {
    show ("Hello, I'm _!" (name of robot))
}

---
page: Domain-specific languages
type: text
locked: true
---

This code just looks like a more complicated way to reassign the `robot` constant. But watch what happens if we move the body of the `with` expression into its own function:

---
page: Domain-specific languages
type: code
---

Robot : type {
    name :: Text
}

[context]
robot :: Robot
robot : error "`robot` not initialized"

say-hello :: () -> ()
say-hello : () -> show ("Hello, I'm _!" (name of robot))

with (robot : Robot { name : "Bot" }) {
    say-hello ()
}

---
page: Domain-specific languages
type: text
locked: true
---

It still works, even though `say-hello` is defined _outside_ the `with` expression! We can abstract away the `with` expression into its own function, too:

---
page: Domain-specific languages
type: code
---

Robot : type {
    name :: Text
}

[context]
robot :: Robot
robot : error "`robot` not initialized"

say-hello :: () -> ()
say-hello : () -> show ("Hello, I'm _!" (name of robot))

with-robot :: Text -> (() -> ()) -> ()
with-robot : name f -> with (robot : Robot { name }) (f ())

with-robot "Bot" (() -> {
    say-hello ()
})

---
page: Domain-specific languages
type: text
locked: true
---

This is about as clean as we can get using regular Wipple syntax. Let's make it even easier to use by defining our own syntax!

---
page: Domain-specific languages
type: code
---

with-robot : syntax {
    with-robot 'name 'body -> with (robot : Robot { name : 'name }) 'body
}

---
page: Domain-specific languages
type: text
locked: true
---

But wait, `Robot` isn't defined in this code box! How does this code even compile? The key is the **placeholders** that begin with a single quote (`'`). The syntax isn't expanded until you use it!

---
page: Domain-specific languages
type: code
---

with-robot : syntax {
    with-robot 'name 'body -> with (robot : Robot { name : 'name }) 'body
}

with-robot "Bot" {
    ...
}

---
page: Domain-specific languages
type: text
locked: true
---

Now it errors! If you haven't already by this point, try disabling Beginner mode to see the full error message. Wipple helpfully tells you the location inside the `syntax` where the error occurred!

Let's break down `syntax` step by step. `syntax` works similarly to `when`, but operates on _code_ instead of _data_. The left-hand side of the arrow is a **syntax rule**, and the right-hand side is expanded if the code matches the syntax rule. If none of the rules match, Wipple issues an error at compile-time. The quoted placeholders allow you to refer to the code provided by the user on the right-hand side. For example, here's a simple syntax rule that adds two numbers (it could easily be a function, too):

---
page: Domain-specific languages
type: code
---

add : syntax {
    add 'a 'b -> 'a + 'b
}

show (add 1 2)

---
page: Domain-specific languages
type: text
locked: true
---

You can add your own **keywords** to the syntax rule as well:

---
page: Domain-specific languages
type: code
---

subtract : syntax {
    subtract 'a from 'b -> 'b - 'a
}

show (subtract 7 from 10)

---
page: Domain-specific languages
type: text
locked: true
---

One powerful feature `syntax` has that regular functions don't is the ability to accept a **variable** number of inputs, using `...` instead of `'`:

---
page: Domain-specific languages
type: code
---

add : syntax {
    add ...x -> 0 ...(+ 'x)
}

show (add)
show (add 1)
show (add 1 2)
show (add 1 2 3 4)

---
page: Domain-specific languages
type: text
locked: true
---

That's how `,` (the list operator) works, by the way!

Alright, let's go back to our robot example, and add in some custom syntax!

---
page: Domain-specific languages
type: code
---

Robot : type {
    name :: Text
}

[context]
robot :: Robot
robot : error "`robot` not initialized"

with-robot : syntax {
    with-robot 'name 'body -> with (robot : Robot { name : 'name }) 'body
}

say-hello : syntax {
    say-hello -> show ("Hello, I'm _!" (name of robot))
}

with-robot "Bot" {
    (say-hello)
}

---
page: Domain-specific languages
type: text
locked: true
---

Awesome!

## Custom operators

You can declare your own operators using `syntax`, too. The only difference is that you need to add the `[operator]` attribute and specify the operator's **precedence** (priority). For example, `*` has `Multiplication-Precedence`, which is higher than `+`'s `Addition-Precedence`.

---
page: Domain-specific languages
type: code
---

[operator Addition-Precedence]
says : syntax {
    'person says 'greeting -> show ("_, I'm _!" 'greeting 'person)
}

"Alice" says "Hello"

---
page: Domain-specific languages
type: text
locked: true
---

With custom syntax and contextual constants, you can build your own programming language right inside Wipple. Your imagination is the limit!

## Sharing your code

You can package up your code into a file and share it with others so they can `use` it. The easiest way to do this is to copy your code into a `.wpl` file and upload it to [GitHub](https://github.com). You can then `use` it like so:

---
page: Domain-specific languages
type: code
---

use "https://raw.githubusercontent.com/wipplelang/playground-examples/main/robot.wpl"

with-robot "Bot" {
    (say-hello)
}


---
page: Type-level programming
type: text
locked: true
---

As you've already seen, Wipple has a powerful type system that lets you express complex relationships between types. But we can go further. What if we don't care about values at all? Welcome to the world of type-level programming!

When you declare a type or a trait, you can leave off the value(s) stored inside to get a **marker** type or trait that can only be used at the type level:

---
page: Type-level programming
type: code
---

Carnivore : type
Herbivore : type

Animals : type
Plants : type

Eat : Animal Food => trait

instance (Eat Carnivore Animals)
instance (Eat Herbivore Plants)

---
page: Type-level programming
type: text
locked: true
---

Now that we've defined our relationships, let's ask Wipple to find for us which kind of animal eats plants!

---
page: Type-level programming
type: code
---

Carnivore : type
Herbivore : type

Animals : type
Plants : type

Eat : Animal Food => trait

instance (Eat Carnivore Animals)
instance (Eat Herbivore Plants)

plant-eater :: Animal where (Eat Animal Plants) => Animal
plant-eater : ...

---
page: Type-level programming
type: text
locked: true
---

Hover over `plant-eater` and you'll see that Wipple determined it's a `Herbivore`!

Wipple's type system is essentially a logic programming language, where `type`s are values, `trait`s are predicates, and `where` clauses are queries. Let's now do something really cool — we can define addition using this logic programming language!

---
page: Type-level programming
type: code
---

-- Define our values
Z : type
S : N => type

---
page: Type-level programming
type: text
locked: true
---

First, we'll define the natural numbers, where `Z` is zero and `S N` is the "successor" of a number `N`. In the world of type-level programming, `S` is a function with input `N` that produces a type `S N`. For example, `S (S (S Z))` represents the number 3.

Now we can define addition with two rules:

  1. Adding $0$ to a number $b$ produces that number (identity).
  2. Adding $a + 1$ to an number $b$ is the same as adding $1$ to $a + b$ (associativity).

---
page: Type-level programming
type: code
---

-- Define our values
Z : type
S : N => type

-- Define the relationship
Add : A B Sum => trait

-- Define our cases
B => instance (Add Z B B) -- (1)
A B Sum where (Add A B Sum) => instance (Add (S A) B (S Sum)) -- (2)

---
page: Type-level programming
type: text
locked: true
---

Alright, let's make a query using a `where` clause!

---
page: Type-level programming
type: code
---

-- Define our values
Z : type
S : N => type

-- Define the relationship
Add : A B Sum => trait

-- Define our cases
B => instance (Add Z B B) -- (1)
A B Sum where (Add A B Sum) => instance (Add (S A) B (S Sum)) -- (2)

-- Make a query: what is 2 + 3?
sum :: Sum where (Add (S (S Z)) (S (S (S Z))) Sum) => Sum
sum : ...

---
page: Type-level programming
type: text
locked: true
---

Hover over `sum`, count the number of `S`s, and you will find that $2 + 3 = 5$! 🤯

Let's try another example, following the same four steps:

---
page: Type-level programming
type: code
---

-- Define our values
Z : type
S : N => type
True : type
False : type

-- Define the relationship
[sealed]
[allow-overlapping-instances]
Equal : A B Are-Equal => trait

-- Define our cases
A => instance (Equal A A True)
A B Are-Equal where (Equal A B Are-Equal) => instance (Equal (S A) (S B) Are-Equal)
A B => instance (Equal A B False)

-- Make a query: is 2 equal to 1?
test-1 :: Are-Equal where (Equal (S (S Z)) (S Z) Are-Equal) => Are-Equal
test-1 : ...

-- Make a query: is 2 equal to 2?
test-2 :: Are-Equal where (Equal (S (S Z)) (S (S Z)) Are-Equal) => Are-Equal
test-2 : ...

---
page: Type-level programming
type: text
locked: true
---

And indeed, $2 = 1$ is false and $2 = 2$ is true! Notice that we need to use `[sealed]` and `[allow-overlapping-instances]` because the `S A` and `S B` in the second `instance` could also potentially satisfy the `A` in the first instance if `A` and `B` are the same, so we need to tell Wipple to give the first `instance` priority.

Let's combine both `Add` and `Equal` to do some algebra!

---
page: Type-level programming
type: code
---

-- Define our values
Z : type
S : N => type

Add : A B Sum => trait
B => instance (Add Z B B)
A B Sum where (Add A B Sum) => instance (Add (S A) B (S Sum))

[sealed]
[allow-overlapping-instances]
Equal : A B => trait -- we don't need `Are-Equal` for this example
A => instance (Equal A A)
A B where (Equal A B) => instance (Equal (S A) (S B))

-- Find y if x = 1 and x + 1 = y.
y :: X Y where (Equal X (S Z)) (Add X (S Z) Y) => Y
y : ...

---
page: Type-level programming
type: text
locked: true
---

Is your mind blown yet?!


---
page: Rendering HTML
type: text
locked: true
---

`show` doesn't only print plain text. If you include HTML in your output, the Wipple Playground will automatically render it!

---
page: Rendering HTML
type: code
---

show "<h1 style='color: orange'>Hello, world!</h1>"

---
page: Rendering HTML
type: text
locked: true
---

If you don't need the full power of HTML, you can use a simpler syntax called [Markdown](https://www.markdownguide.org). Here are the basics:

  -  `# Text` creates a header. `#` corresponds to `<h1>`, `##` corresponds to `<h2>`, etc.
  -  `**Text**` makes the text **bold** and `_Text_` makes it _italic_.
  -  `- Text` and `* Text` create a bulleted list, and `1. Text` creates a numbered list.
  -  `[Text](example.com)` creates a link.
  -  `![Alt text](example.com/image.png)` creates an image.
  -  `` `code` `` renders the text as code.
  -  `$math$` renders the text as math using $\LaTeX$.

Try experimenting with HTML and Markdown in the space below!

---
page: Rendering HTML
type: code
---


---
page: Extending Wipple with JavaScript
type: text
locked: true
---

Wipple's interactive features, like turtle graphics, are implemented in [JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide). If you know some JavaScript, you can write your own interactive user interface (UI) and communicate with Wipple code!

The Wipple Playground offers a `with-ui` function that accepts a URL to a JavaScript file. This file must export an `initialize` function and an `onMessage` object, like so:

```javascript
export const onMessage = {};

export const initialize = async (id, container) => {
    onMessage[id] = messageHandler(container);
};

const messageHandler = (container) => (message, value) => {
    switch (message) {
        case "display-text":
            const p = document.createElement('p');
            p.textContent = value;
            container.appendChild(p);
            break;
        default:
            throw new Error("unhandled message");
    }
};
```

The above example is hosted on GitHub [here](https://raw.githubusercontent.com/wipplelang/playground-examples/main/ui-test.js), and you can import it into Wipple like so:

---
page: Extending Wipple with JavaScript
type: code
lint: false
---

url : "https://raw.githubusercontent.com/wipplelang/playground-examples/main/ui-test.js"

with-ui url (ui -> {
    -- TODO
})

---
page: Extending Wipple with JavaScript
type: text
locked: true
---

Now you can send messages to the UI element using `message`:

---
page: Extending Wipple with JavaScript
type: code
---

url : "https://raw.githubusercontent.com/wipplelang/playground-examples/main/ui-test.js"

with-ui url (ui -> {
    ui . message "display-text" "Hello, world!"
})

---
page: Extending Wipple with JavaScript
type: text
locked: true
---

It works! Now we can make a DSL around our custom interface:

---
page: Extending Wipple with JavaScript
type: code
---

My-Interface : type {
    ui :: UI
}

[context]
my-interface :: My-Interface
my-interface : error "`my-interface` used outside `with-my-interface`"

with-my-interface : syntax {
    with-my-interface 'body -> {
        url : "https://raw.githubusercontent.com/wipplelang/playground-examples/main/ui-test.js"

        with-ui url (ui -> {
            with (my-interface : My-Interface { ui }) 'body
        })
    }
}

display-text :: Text -> ()
display-text : text -> ui of my-interface . message "display-text" text

with-my-interface {
    display-text "Hello, world!"
}

---
page: Extending Wipple with JavaScript
type: text
locked: true
---

And let's host that on GitHub, too:

---
page: Extending Wipple with JavaScript
type: code
---

use "https://raw.githubusercontent.com/wipplelang/playground-examples/main/my-interface.wpl"

with-my-interface {
    display-text "Hello, world!"
}

---
page: Extending Wipple with JavaScript
type: text
locked: true
---

You have access to the entire JavaScript API, and you can use [npm](https://npmjs.com) packages if you set up a bundler. For example, Wipple's built-in interfaces like `turtle` and `music` use [React](https://react.dev) and [Vite](https://vitejs.dev) configured in [library mode](https://vitejs.dev/guide/build.html#library-mode). Again, your imagination is the limit!


---
page: Writing efficient code
type: text
locked: true
---

Someday, the code you write could run on thousands or millions of computers around the world. In data centers, computers run 24 hours a way, 7 days a week to serve websites and apps. These computers consume a _lot_ of energy, so if you can make your code more energy efficient, you can save money and the environment!

Wipple has a tool that can measure how much power your computer consumes while it's running your code. To continue, please download the Wipple Playground app using the link below, and re-open this lesson there. If you see **Begin Measuring**, you're all set!

Let's start with a simple program to get a baseline reading of your computer's power consumption. Go ahead and click **Begin Measuring** below. You'll need to enter your password so Wipple can access the system's power metrics. Make sure you don't have any other resource-intensive programs running.

---
page: Writing efficient code
type: code
setup: energy
---

show "Hello, world!"

---
page: Writing efficient code
type: text
locked: true
---

Once the program finishes, Wipple will display the average power consumption in Watts, as well as the total energy use if you were to run your program on a thousand computers for a month. Then, you can compare the emissions and how much it would cost to power these computers on various energy sources!

Let's try writing a program to calculate the $n$th Fibonacci number in three different ways. The first way is the simplest:

---
page: Writing efficient code
type: code
setup: energy
---

fibonacci :: Natural -> Natural
fibonacci : n -> when n {
  0 or 1 -> 1
  n -> fibonacci (n - 2) + fibonacci (n - 1)
}

show (fibonacci 30) -- might take a while!

---
page: Writing efficient code
type: text
locked: true
---

Notice that the same Fibonacci number will be calculated over and over — that's why this program is so slow! We can fix this by using a cache:

---
page: Writing efficient code
type: code
setup: energy
---

fibonacci :: Natural -> Natural
fibonacci : {
  fibonacci-cached :: Mutable (Dictionary Natural Natural) -> Natural -> Natural
  fibonacci-cached : cache n -> when (get cache . entry n) {
    Some cached -> cached
    None -> {
      cached : when n {
        0 or 1 -> 1
        n -> fibonacci-cached cache (n - 2) + fibonacci-cached cache (n - 1)
      }

      cache . insert-entry! (n ; cached)

      cached
    }
  }

  fibonacci-cached (mutable (,))
}

show (fibonacci 30)

---
page: Writing efficient code
type: text
locked: true
---

Much faster, and your computer will consume much less energy!

Let's try the traditional approach, using mutable variables:

---
page: Writing efficient code
type: code
setup: energy
lint: false
---

fibonacci :: Natural -> Natural
fibonacci : n -> when n {
  0 or 1 -> 1
  n -> {
    a : mutable 1
    b : mutable 1
    c : mutable 0

    repeat ((n - 1) times) {
      c . set! (get a + get b)
      a . set! (get b)
      b . set! (get c)
    }

    get b
  }
}

show (fibonacci 30)

---
page: Writing efficient code
type: text
locked: true
---

Even faster!

When you're writing programs in Wipple, generally prefer making your code easy to reason about and follow the conventions of the language (like composing functions). But if you're concerned about performance, it's OK to use mutation and traditional loops in the parts of your program that need it. Always test to see what is causing high CPU usage first!


---
page: Beyond the Playground
type: text
locked: true
---

Congratulations, you've made it to the end of Learn Wipple! 🤩 Now, you can use the Wipple Playground to create anything you want.

## Making your own lessons

If you click on the six dots on the left-hand side of a code box, you can create a new code box or add some text. Depending on which one you choose, you get different options. For code boxes, you can disable lints for a particular code example if you're trying to explain something and don't want the warnings to get in the way. Text boxes are rendered as [Markdown](https://www.markdownguide.org), and when you're done editing, make sure to lock the text box so people don't accidentally expose the Markdown while they're trying to read.

To share your lesson, just copy the URL in the address bar, or click Copy Link in the menu next to the beginner mode toggle at the bottom of the screen.

## Add Wipple to your website

Once you're finished creating something in Wipple, you can export it as a website to embed anywhere! Just click the `•••` icon in the top right of any code editor, and then click **Download Website**.

If you want to add your project to an existing website, you can add the following code to your HTML:

```html
<head>
    ...

    <link rel="stylesheet" href="https://wipple.dev/embed/style.css" />
</head>

<body>
    ...

    <script type="module" src="https://wipple.dev/embed/index.js"></script>

    <wipple>
        <script type="application/wipple">
            -- Your Wipple code here!
        </script>
    </wipple>
</body>
```

You can add multiple `<wipple>` elements anywhere on the page (including inside other elements) and they will all run. You only need to include the CSS and JavaScript from `wipple.dev` once, though.

## Thank you!

Thank you for taking the time to learn Wipple! If you have any feedback, there's a Feedback link in the top right. Good luck on your programming journey!
