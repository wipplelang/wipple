//! Coordinates the compiler passes.

mod convert;
mod render;

use itertools::Itertools;
use serde::{Deserialize, Serialize};
use std::{collections::HashMap, hash::Hash};
use wasm_bindgen::{prelude::wasm_bindgen, JsCast};

pub use wipple_codegen as codegen;
pub use wipple_linker as linker;
pub use wipple_lower as lower;
pub use wipple_parser as parser;
pub use wipple_query as query;
pub use wipple_syntax as syntax;
pub use wipple_typecheck as typecheck;
pub use wipple_util as util;

/// The default recursion limit.
// TODO: Make this configurable
pub const DEFAULT_RECURSION_LIMIT: u32 = 64;

fn initialize() {
    #[cfg(feature = "console_error_panic_hook")]
    console_error_panic_hook::set_once();
}

fn serialize(value: &impl serde::Serialize) -> String {
    serde_json::to_string(value).unwrap()
}

fn deserialize<'de, T: serde::Deserialize<'de>>(value: &'de str) -> T {
    serde_json::from_str(value).expect("malformed input")
}

/// JavaScript entrypoint to the compiler.
#[wasm_bindgen]
pub fn compile(files: &str, dependencies: &str) -> String {
    initialize();

    let files: Vec<File> = deserialize(files);
    let dependencies: Option<Interface> = deserialize(dependencies);

    let driver = Driver::new();
    let result = driver.compile(files, dependencies);

    serialize(&result)
}

/// JavaScript entrypoint to the linker.
#[wasm_bindgen]
pub fn link(libraries: &str) -> String {
    initialize();

    let libraries: Vec<Library> = deserialize(libraries);

    let executable = linker::link(libraries);
    serialize(&executable)
}

/// JavaScript entrypoint to render errors.
#[wasm_bindgen(js_name = "renderErrors")]
pub fn render_errors(errors: &str) -> String {
    initialize();

    let errors: Vec<util::WithInfo<Info, Error>> = deserialize(errors);

    let errors = errors
        .into_iter()
        .map(render::render_error)
        .collect::<Vec<_>>();

    serialize(&errors)
}

/// JavaScript entrypoint to render errors with console colors.
#[wasm_bindgen(js_name = "colorizeErrors")]
pub fn colorize_errors(errors: &str, source_code_for_file: wasm_bindgen::JsValue) -> String {
    initialize();

    let errors: Vec<render::Error> = deserialize(errors);

    let source_code_for_file = |file: &str| {
        source_code_for_file
            .dyn_ref::<js_sys::Function>()
            .unwrap()
            .call1(&wasm_bindgen::JsValue::NULL, &file.into())
            .unwrap()
            .as_string()
            .unwrap()
    };

    let colorized = render::colorize_errors(&errors, source_code_for_file);
    serialize(&colorized)
}

/// The driver.
#[non_exhaustive]
#[derive(Debug)]
pub struct Driver {
    /// The recursion limit.
    pub recursion_limit: u32,

    interface: Interface,
    library: Library,
}

impl Driver {
    /// Create a new driver.
    pub fn new() -> Self {
        Driver {
            recursion_limit: DEFAULT_RECURSION_LIMIT,
            interface: Default::default(),
            library: Default::default(),
        }
    }
}

/// The information contained within items produced by the compiler.
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Info {
    /// Information produced by the parser.
    pub parser_info: parser::syntax::Info,
}

impl From<parser::syntax::Info> for Info {
    fn from(parser_info: parser::syntax::Info) -> Self {
        Info { parser_info }
    }
}

/// A file provided to [`Driver::compile`].
#[derive(Debug, Clone, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct File {
    /// The file's path.
    pub path: String,

    /// The file's contents.
    pub code: String,
}

/// An interface generated by the compiler.
#[non_exhaustive]
#[derive(Debug, Default, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Interface {
    /// The names of top-level declarations in the program.
    pub top_level: HashMap<String, Vec<lower::Path>>,

    /// The type declarations in the program.
    pub type_declarations:
        HashMap<lower::Path, util::WithInfo<Info, typecheck::TypeDeclaration<Driver>>>,

    /// The trait declarations in the program.
    pub trait_declarations:
        HashMap<lower::Path, util::WithInfo<Info, typecheck::TraitDeclaration<Driver>>>,

    /// The type parameters in the program.
    pub type_parameter_declarations:
        HashMap<lower::Path, util::WithInfo<Info, typecheck::TypeParameterDeclaration<Driver>>>,

    /// The language declarations in the program.
    pub language_declarations: HashMap<String, lower::Path>,

    /// The constant declarations in the program.
    pub constant_declarations:
        HashMap<lower::Path, util::WithInfo<Info, typecheck::ConstantDeclaration<Driver>>>,

    /// The instance declarations in the program.
    pub instance_declarations:
        HashMap<lower::Path, util::WithInfo<Info, typecheck::InstanceDeclaration<Driver>>>,
}

/// A library generated by the compiler.
pub type Library = wipple_linker::UnlinkedLibrary<Driver>;

/// An analyzed expression along with its compiled IR.
pub type Item = wipple_linker::UnlinkedItem<Driver>;

/// The result of [`Driver::compile`].
#[non_exhaustive]
#[derive(Debug, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct Result {
    /// The generated interface.
    pub interface: Interface,

    /// The generated library.
    pub library: Library,

    /// Any errors ocurring during compilation.
    pub errors: Vec<util::WithInfo<Info, Error>>,
}

/// Errors produced by the compiler.
#[allow(missing_docs)]
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub enum Error {
    Read(parser::reader::Error),
    Parse(parser::syntax::Error),
    Syntax(syntax::Error),
    Lower(lower::Error),
    Typecheck(typecheck::Error<Driver>),
}

impl Driver {
    /// Compile a set of source files into a [`Library`] and [`Interface`].
    pub fn compile(
        mut self,
        files: impl IntoIterator<Item = File>,
        dependencies: Option<Interface>,
    ) -> Result {
        let mut errors = Vec::new();

        let files = files.into_iter().map(|file| {
            let options = parser::reader::ReadOptions {
                strip_comments: true,
            };

            let tokenize_result = parser::reader::tokenize(&file.code);
            errors.extend(
                tokenize_result
                    .errors
                    .into_iter()
                    .map(|error| util::WithInfo {
                        info: Info {
                            parser_info: parser::syntax::Info {
                                path: file.path.clone(),
                                span: error.span.clone(),
                            },
                        },
                        item: Error::Read(error),
                    }),
            );

            let read_result = wipple_parser::reader::read(tokenize_result.tokens, options);
            errors.extend(read_result.errors.into_iter().map(|error| util::WithInfo {
                info: Info {
                    parser_info: parser::syntax::Info {
                        path: file.path.clone(),
                        span: error.span.clone(),
                    },
                },
                item: Error::Read(error),
            }));

            let syntax_driver = SyntaxDriver {
                file_path: file.path.clone(),
            };

            let syntax_result = wipple_parser::syntax::parse(&syntax_driver, read_result.top_level);
            errors.extend(
                syntax_result
                    .errors
                    .into_iter()
                    .map(|error| util::WithInfo {
                        info: Info {
                            parser_info: parser::syntax::Info {
                                path: file.path.clone(),
                                span: error.span.clone(),
                            },
                        },
                        item: Error::Parse(error),
                    }),
            );

            let parse_result = wipple_syntax::parse(&syntax_driver, syntax_result.top_level);
            errors.extend(
                parse_result
                    .errors
                    .into_iter()
                    .map(|error| error.map(Error::Syntax).map_info(Info::from)),
            );

            convert::lower::convert(parse_result.top_level)
        });

        let lower_result = wipple_lower::resolve(
            &self,
            files,
            dependencies
                .map(|interface| lower::Interface {
                    top_level: interface.top_level,
                    type_declarations: interface
                        .type_declarations
                        .into_iter()
                        .map(|(path, item)| {
                            (path, convert::interface::convert_type_declaration(item))
                        })
                        .collect(),
                    trait_declarations: interface
                        .trait_declarations
                        .into_iter()
                        .map(|(path, item)| {
                            (path, convert::interface::convert_trait_declaration(item))
                        })
                        .collect(),
                    type_parameter_declarations: interface
                        .type_parameter_declarations
                        .into_iter()
                        .map(|(path, item)| {
                            (
                                path,
                                convert::interface::convert_type_parameter_declaration(item),
                            )
                        })
                        .collect(),
                    language_declarations: interface.language_declarations,
                    constant_declarations: interface
                        .constant_declarations
                        .into_iter()
                        .map(|(path, item)| {
                            (path, convert::interface::convert_constant_declaration(item))
                        })
                        .collect(),
                    instance_declarations: interface
                        .instance_declarations
                        .into_iter()
                        .map(|(path, item)| {
                            (path, convert::interface::convert_instance_declaration(item))
                        })
                        .collect(),
                })
                .unwrap_or_default(),
        );

        errors.extend(
            lower_result
                .errors
                .into_iter()
                .map(|error| error.map(Error::Lower)),
        );

        self.interface.top_level = lower_result.interface.top_level;

        for (path, item) in lower_result.interface.type_declarations {
            let declaration = convert::typecheck::convert_type_declaration(item);
            self.interface.type_declarations.insert(path, declaration);
        }

        for (path, item) in lower_result.interface.trait_declarations {
            let declaration = convert::typecheck::convert_trait_declaration(item);
            self.interface.trait_declarations.insert(path, declaration);
        }

        for (path, item) in lower_result.interface.type_parameter_declarations {
            let declaration = convert::typecheck::convert_type_parameter_declaration(item);
            self.interface
                .type_parameter_declarations
                .insert(path, declaration);
        }

        self.interface.language_declarations = lower_result.interface.language_declarations;

        for (path, item) in &lower_result.interface.constant_declarations {
            let declaration = convert::typecheck::convert_constant_declaration(item.clone());

            self.interface
                .constant_declarations
                .insert(path.clone(), declaration);
        }

        for (path, item) in &lower_result.interface.instance_declarations {
            let declaration = convert::typecheck::convert_instance_declaration(item.clone());

            self.interface
                .instance_declarations
                .insert(path.clone(), declaration);
        }

        for (path, item) in lower_result.interface.constant_declarations {
            let body = match lower_result.library.items.get(&path) {
                Some(body) => body.clone(),
                None => continue,
            };

            let declaration = convert::typecheck::convert_constant_declaration(item);

            let typecheck_result = wipple_typecheck::resolve(
                &self,
                (
                    declaration.clone(),
                    convert::typecheck::convert_expression(body),
                ),
            );

            errors.extend(
                typecheck_result
                    .errors
                    .into_iter()
                    .map(|error| error.map(Error::Typecheck)),
            );

            let codegen_result =
                codegen::compile(&self, path.clone(), typecheck_result.item.as_ref(), false);

            self.library.items.insert(
                path,
                Item {
                    expression: typecheck_result.item,
                    ir: codegen_result.map(|result| result.labels),
                },
            );
        }

        for (path, item) in lower_result.interface.instance_declarations {
            let body = match lower_result.library.items.get(&path) {
                Some(body) => body.clone(),
                None => continue,
            };

            let declaration = convert::typecheck::convert_instance_declaration(item);

            let typecheck_result = wipple_typecheck::resolve(
                &self,
                (
                    declaration.clone(),
                    convert::typecheck::convert_expression(body),
                ),
            );

            errors.extend(
                typecheck_result
                    .errors
                    .into_iter()
                    .map(|error| error.map(Error::Typecheck)),
            );

            let codegen_result =
                codegen::compile(&self, path.clone(), typecheck_result.item.as_ref(), false);

            self.library.items.insert(
                path,
                Item {
                    expression: typecheck_result.item,
                    ir: codegen_result.map(|result| result.labels),
                },
            );
        }

        {
            let typecheck_result = wipple_typecheck::resolve(
                &self,
                wipple_util::WithInfo {
                    info: <Self as wipple_typecheck::Driver>::top_level_info(&self),
                    item: lower_result
                        .library
                        .code
                        .into_iter()
                        .map(convert::typecheck::convert_expression)
                        .collect(),
                },
            );

            errors.extend(
                typecheck_result
                    .errors
                    .into_iter()
                    .map(|error| error.map(Error::Typecheck)),
            );

            let codegen_result = codegen::compile(
                &self,
                lower::Path::top_level(),
                typecheck_result.item.as_ref(),
                true,
            );

            self.library.code.push(Item {
                expression: typecheck_result.item,
                ir: codegen_result.map(|result| result.labels),
            });
        }

        let instances_by_trait = self
            .interface
            .instance_declarations
            .iter()
            .into_group_map_by(|(_, instance)| instance.item.instance.item.r#trait.clone());

        for (r#trait, instances) in instances_by_trait {
            let instances = instances
                .into_iter()
                .map(|(path, _)| path.clone())
                .collect::<Vec<_>>();

            let overlap_errors = typecheck::instances_overlap(&self, &r#trait, instances.clone());

            errors.extend(
                overlap_errors
                    .into_iter()
                    .map(|error| error.map(Error::Typecheck)),
            );

            self.library.instances.insert(r#trait.clone(), instances);
        }

        macro_rules! insert_intrinsic {
            ($name:literal, $intrinsics:ident) => {
                if let Some(value) = self.interface.language_declarations.get($name) {
                    self.library
                        .$intrinsics
                        .insert(String::from($name), value.clone());
                }
            };
        }

        insert_intrinsic!("text", intrinsic_type_descriptors);

        insert_intrinsic!("number", intrinsic_type_descriptors);

        insert_intrinsic!("boolean", intrinsic_type_descriptors);
        insert_intrinsic!("true", intrinsic_variants);
        insert_intrinsic!("false", intrinsic_variants);

        insert_intrinsic!("maybe", intrinsic_type_descriptors);
        insert_intrinsic!("none", intrinsic_variants);
        insert_intrinsic!("some", intrinsic_variants);

        insert_intrinsic!("list", intrinsic_type_descriptors);

        insert_intrinsic!("ui-handle", intrinsic_type_descriptors);

        insert_intrinsic!("task-group", intrinsic_type_descriptors);

        Result {
            interface: self.interface,
            library: self.library,
            errors: errors.into_iter().unique().collect(),
        }
    }
}

struct SyntaxDriver {
    file_path: String,
}

impl wipple_syntax::Driver for SyntaxDriver {
    type Info = Info;

    fn file_path(&self) -> String {
        self.file_path.clone()
    }

    fn merge_info(left: Self::Info, right: Self::Info) -> Self::Info {
        Info {
            parser_info: parser::syntax::Info {
                path: left.parser_info.path,
                span: left.parser_info.span.start..right.parser_info.span.end,
            },
        }
    }
}

impl wipple_lower::Driver for Driver {
    type Info = Info;
}

impl wipple_typecheck::Driver for Driver {
    type Info = Info;
    type Path = wipple_lower::Path;

    fn recursion_limit(&self) -> u32 {
        self.recursion_limit
    }

    fn top_level_info(&self) -> Self::Info {
        wipple_parser::syntax::Info {
            path: String::from("top-level"),
            span: 0..0,
        }
        .into()
    }

    fn path_for_language_type(&self, language_item: &'static str) -> Option<Self::Path> {
        Some(
            self.interface
                .language_declarations
                .get(language_item)?
                .clone(),
        )
    }

    fn path_for_language_trait(&self, language_item: &'static str) -> Option<Self::Path> {
        Some(
            self.interface
                .language_declarations
                .get(language_item)?
                .clone(),
        )
    }

    fn paths_are_equal(&self, left: &Self::Path, right: &Self::Path) -> bool {
        left == right
    }

    fn get_type_declaration(
        &self,
        path: &Self::Path,
    ) -> util::WithInfo<Self::Info, wipple_typecheck::TypeDeclaration<Self>> {
        self.interface
            .type_declarations
            .get(path)
            .expect("missing type declaration")
            .clone()
    }

    fn get_trait_declaration(
        &self,
        path: &Self::Path,
    ) -> util::WithInfo<Self::Info, wipple_typecheck::TraitDeclaration<Self>> {
        self.interface
            .trait_declarations
            .get(path)
            .expect("missing trait declaration")
            .clone()
    }

    fn get_type_parameter_declaration(
        &self,
        path: &Self::Path,
    ) -> util::WithInfo<Self::Info, wipple_typecheck::TypeParameterDeclaration<Self>> {
        self.interface
            .type_parameter_declarations
            .get(path)
            .expect("missing type parameter declaration")
            .clone()
    }

    fn get_constant_declaration(
        &self,
        path: &Self::Path,
    ) -> util::WithInfo<Self::Info, wipple_typecheck::ConstantDeclaration<Self>> {
        self.interface
            .constant_declarations
            .get(path)
            .expect("missing constant declaration")
            .clone()
    }

    fn get_instance_declaration(
        &self,
        path: &Self::Path,
    ) -> util::WithInfo<Self::Info, wipple_typecheck::InstanceDeclaration<Self>> {
        self.interface
            .instance_declarations
            .get(path)
            .expect("missing instance declaration")
            .clone()
    }

    fn get_instances_for_trait(&self, r#trait: &Self::Path) -> Vec<Self::Path> {
        self.interface
            .instance_declarations
            .iter()
            .filter(|(_, instance)| instance.item.instance.item.r#trait == *r#trait)
            .map(|(path, _)| path.clone())
            .collect()
    }

    fn get_enumeration_for_variant(&self, variant: &Self::Path) -> Self::Path {
        // The parent of a variant is its enumeration
        lower::Path(variant[0..variant.len() - 1].to_vec())
    }
}

impl wipple_codegen::Driver for Driver {
    fn true_variant(&self) -> Option<Self::Path> {
        self.interface.language_declarations.get("true").cloned()
    }

    fn number_type(&self) -> Option<Self::Path> {
        self.interface.language_declarations.get("number").cloned()
    }

    fn text_type(&self) -> Option<Self::Path> {
        self.interface.language_declarations.get("text").cloned()
    }

    fn number_equality_intrinsic(&self) -> Option<String> {
        Some(String::from("number-equality"))
    }

    fn text_equality_intrinsic(&self) -> Option<String> {
        Some(String::from("text-equality"))
    }
}

impl wipple_linker::Driver for Driver {}
