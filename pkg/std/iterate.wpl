[[no-std]]

use "./util.wpl"
use "./fp.wpl"
use "./mutable.wpl"
use "./list.wpl"

[help "A container for an iterable value that produces the `next` value on demand."]
Iterator : Context Element => type {
	context :: Mutable Context
	next :: Mutable Context -> Maybe Element
}

[help "Implement this trait to enable traversing your collection type."]
Iterate : Context Container Element => trait (Container -> Iterator Context Element)

Context Element => instance Iterate Context (Iterator Context Element) Element : it

-- reduce :: Context Container Element Result where (Iterate Context Container Element) => (Element -> Result -> Result) -> Container -> Iterator Context Result
-- reduce : TODO

-- TODO: Use higher-kinded types
[help "Keep only the items that satisfy the provided condition."]
filter :: Context Container Element where (Iterate Context Container Element) => (Element -> Boolean) -> Container -> Iterator Context Element
filter : include? -> container -> {
	{ context next } : Iterate container
	Iterator {
		context : context
		next : context -> loop {
			when (next context) {
				Some x -> if (include? x) (break (Some x)) (continue)
				None -> break None
			}
		}
	}
}

-- TODO: Use higher-kinded types
[help "Execute a function for each item in an iterator."]
each :: Context Container Element where (Iterate Context Container Element) => (Element -> ()) -> Container -> ()
each : f -> container -> {
	{ context next } : Iterate container

	loop {
		when (next context) {
			Some x -> {
				f x
				continue
			}
			None -> break ()
		}
	}
}

-- TODO: Use higher-kinded types
[help "Implement this trait to enable reducing an iterator into your collection type."]
Collect : Context Element Container => trait (Iterator Context Element -> Container)

-- TODO: Use higher-kinded types
[help "Collect an iterator into a single value, like a `List`."]
collect :: Context Input Element Output where (Iterate Context Input Element) (Collect Context Element Output) => Input -> Output
collect : input -> Collect (Iterate input)

Context Element => instance Collect Context Element (List Element) : { context next } -> {
	list : mutable (list ())
	loop {
		when (next context) {
			Some x -> {
				list . append! x
				continue
			}
			None -> break ()
		}
	}

	get list
}

Context Element => instance Collect Context Text Text : { context next } -> {
	text : mutable ""
	loop {
		when (next context) {
			Some x -> {
				text . add! x
				continue
			}
			None -> break ()
		}
	}

	get text
}

A => instance Iterate Number (List A) A : list -> Iterator {
	context : mutable 0
	next : index -> {
		when (list . at (get index)) {
			OK element -> {
				increment! index
				Some element
			}
			Error _ -> None
		}
	}
}
