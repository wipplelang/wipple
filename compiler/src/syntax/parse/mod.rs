//! Parse a token tree into an abstract syntax tree.

mod base;
mod render;
mod rules;

pub use rules::*;

use crate::{
    syntax::{
        Location,
        tokenize::{Keyword, NonAssociativeOperator, Operator, TokenTree},
    },
    util::WithInfo,
};
use std::{fmt::Debug, hash::Hash};

/// A diagnostic generated by the parser.
#[derive(Debug, Hash)]
pub struct Diagnostic {
    /// The expected piece of syntax at this location.
    pub expected: SyntaxKind,

    /// Whether the diagnostic refers to the token before or after the expected
    /// syntax.
    pub direction: Option<Direction>,

    /// The syntax rules matched so far.
    pub stack: Vec<WithInfo<SyntaxKind>>,
}

/// Whether a [`Diagnostic`] refers to the token before of after the expected
/// syntax.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Direction {
    Before(SyntaxKind),
    After(SyntaxKind),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash, strum::Display)]
#[strum(serialize_all = "kebab-case")]
pub enum SyntaxKind {
    TopLevel,
    Attribute,
    AttributeValue,
    Name,
    Number,
    Text,
    Statement,
    LeftParenthesis,
    LeftBrace,
    Keyword(Keyword),
    ContextualKeyword(String),
    Operator(Operator),
    NonAssociativeOperator(NonAssociativeOperator),
    Instance,
    TypeParameter,
    Pattern,
    WildcardPattern,
    NumberPattern,
    TextPattern,
    VariantPattern,
    DestructurePattern,
    TuplePattern,
    OrPattern,
    MutatePattern,
    AnnotatePattern,
    Expression,
    Type,
    PlaceholderType,
    DeclaredType,
    FunctionType,
    TupleType,
    BlockType,
    IntrinsicType,
    MessageType,
    EqualType,
    TypeMember,
    FieldDeclaration,
    VariantDeclaration,
    Arm,
    TypeFunction,
    TypeRepresentation,
    SyntaxDeclaration,
    TypeDeclaration,
    TraitDeclaration,
    InstanceDeclaration,
    ConstantDeclaration,
    LanguageDeclaration,
    Assignment,
    AnnotateExpression,
    NameExpression,
    NumberExpression,
    TextExpression,
    DoExpression,
    CallExpression,
    ApplyExpression,
    BinaryOperatorExpression,
    AsExpression,
    IsExpression,
    WhenExpression,
    IntrinsicExpression,
    TupleExpression,
    CollectionExpression,
    StructureExpression,
    StructureField,
    WhenBody,
    WhenArm,
    BlockExpression,
    FunctionExpression,
    FunctionInputs,
    Nothing,
}

#[derive(Debug)]
pub struct Result<T> {
    pub parsed: WithInfo<T>,
    pub diagnostics: Vec<WithInfo<Diagnostic>>,
}

/// Parse a token tree into a concrete top-level syntax tree.
pub fn parse_top_level(tree: WithInfo<&TokenTree<'_>>) -> Result<TopLevel>
where
    Location: From<Location>,
{
    parse_rule(tree, rules::top_level())
}
