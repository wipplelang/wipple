[[no-std]]

use "util.wpl"
use "fp.wpl"
use "mutable.wpl"
use "list.wpl"
use "logic.wpl"
use "loop.wpl"

[help "A container for an iterable value that produces the `next` value on demand."]
Iterator : Element => type {
	next :: () -> Maybe Element
}

[help "Create an iterator from a function."]
iterator :: Element => (() -> Maybe Element) -> Iterator Element
iterator : next -> Iterator { next }

[help "Retrieve the next item in an iterator."]
next :: Element => Iterator Element -> Maybe Element
next : { next } -> next ()

[help "Implement this trait to enable traversing your collection type."]
Iterate : Container Element => trait (Container -> Iterator Element)

Element => instance (Iterate (Iterator Element) Element) : it

[help "Transform each item in an iterator, producing a new iterator."]
transform :: Container Element Result where (Iterate Container Element) => (Element -> Result) -> Container -> Iterator Result
transform : f -> container -> {
	base : Iterate container

	iterator (() -> when (next base) {
		Some x -> Some (f x)
		None -> None
	})
}

[help "Keep only the items in an iterator that satisfy the provided condition."]
filter :: Container Element where (Iterate Container Element) => (Element -> Boolean) -> Container -> Iterator Element
filter : include? -> container -> {
	base : Iterate container

	iterator (() -> loop {
		when (next base) {
			Some x ->
				if (include? x)
					(Break (Some x))
					(Continue :: Control-Flow (Maybe _))  -- type annotation is needed because of typechecker bug
			None -> Break None
		}
	})
}

-- reduce :: Container Element Result where (Iterate Container Element) => (Element -> Result -> Result) -> Container -> Iterator Result
-- reduce : TODO

[help "Implement this trait to enable reducing an iterator into your collection type."]
Collect : Element Container => trait (Iterator Element -> Container)

[help "Collect an iterator into a single value, like a `List`."]
collect :: Input Element Output where (Iterate Input Element) (Collect Element Output) => Input -> Output
collect : input -> Collect ((Iterate :: (_ -> Iterator Element)) input) -- FIXME: Remove type annotation once we have functional dependencies

Element => instance (Collect Element (List Element)) : iterator -> {
	list : mutable (list)
	loop {
		when (next iterator) {
			Some x -> {
				list . append! x
				Continue
			}
			None -> Break ()
		}
	}

	get list
}

A => instance (Iterate (List A) A) : list -> {
	index : mutable 0

	iterator (() -> when (list . nth (get index)) {
		OK element -> {
			increment! index
			Some element
		}
		Error _ -> None
	})
}

instance (Collect () ()) : iterator -> {
	loop {
		when (next iterator) {
			Some () -> Continue
			None -> Break ()
		}
	}
}

[help "Perform an action for each item in an iterator."]
each :: Container Element where (Iterate Container Element) => (Element -> ()) -> Container -> ()
each : f -> container -> container . transform f . collect

[help "Split an iterator into groups of consecutive items satisfying a condition."]
split-by :: Collection Element where (Iterate Collection Element) => (Element -> Boolean) -> Collection -> Iterator (List Element)
split-by : separator? -> collection -> {
	base : Iterate collection
	group : mutable (Some (list))

	iterator (() -> loop {
		when (next base) {
			Some x -> {
				if (separator? x) {
					Break (take! group)
				} {
					group . set! (Some (when (get group) {
						Some inner -> inner . append x
						None -> list x
					}))

					Continue
				}
			}
			None -> Break (take! group)
		}
	})
}

[help "Split an iterator into groups of consecutive items equal to a value."]
split :: Collection Element where (Iterate Collection Element) (Equal Element) => Element -> Collection -> Iterator (List Element)
split : separator -> split-by (x -> x = separator)

count :: Collection Element where (Iterate Collection Element) => Collection -> Natural
count : collection -> {
	iterator : Iterate collection

	count : mutable 0
	loop {
		when (next iterator :: Maybe Element) {
			Some _ -> {
				increment! count
				Continue
			}
			None -> Break ()
		}
	}

	get count
}
