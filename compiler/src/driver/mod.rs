//! Coordinates the compiler passes.

mod convert;

use crate::{
    codegen::{Codegen, Executable},
    lower::{self, Path},
    syntax::{self, Location},
    typecheck, util,
};
use itertools::Itertools;
use serde::Deserialize;
use std::{collections::HashMap, sync::Arc};

/// The default recursion limit.
// TODO: Make this configurable
pub const DEFAULT_RECURSION_LIMIT: u32 = 64;

/// The driver.
#[non_exhaustive]
#[derive(Debug, Clone)]
pub struct Driver {
    recursion_limit: u32,
    pub(crate) interface: Interface,
    items: HashMap<lower::Path, util::WithInfo<typecheck::TypedExpression>>,
    entrypoint: Option<Path>,
}

impl Driver {
    pub fn new() -> Self {
        Driver {
            recursion_limit: DEFAULT_RECURSION_LIMIT,
            interface: Default::default(),
            items: Default::default(),
            entrypoint: None,
        }
    }
}

impl Driver {
    pub fn format(code: &str) -> String {
        match syntax::tokenize::tokenize("format", code).collect::<std::result::Result<Vec<_>, _>>()
        {
            Ok(tokens) => {
                syntax::tokenize::format(tokens.iter().map(|token| &token.item).collect())
            }
            Err(_) => code.to_string(),
        }
    }
}

/// A file provided to [`Driver::compile`].
#[derive(Debug, Clone, Deserialize)]
pub struct File {
    /// The file's path.
    pub path: String,

    /// The file's contents.
    pub code: String,
}

/// An interface generated by the compiler.
#[non_exhaustive]
#[derive(Debug, Clone, Default)]
pub struct Interface {
    /// The files used during compilation. Not all files may be available.
    pub files: Vec<File>,

    /// The names of top-level declarations in the program.
    pub top_level: HashMap<String, Vec<util::WithInfo<lower::Path>>>,

    /// The syntax declarations in the program.
    pub syntax_declarations: HashMap<lower::Path, util::WithInfo<typecheck::SyntaxDeclaration>>,

    /// The type declarations in the program.
    pub type_declarations: HashMap<lower::Path, util::WithInfo<typecheck::TypeDeclaration>>,

    /// The trait declarations in the program.
    pub trait_declarations: HashMap<lower::Path, util::WithInfo<typecheck::TraitDeclaration>>,

    /// The type parameters in the program.
    pub type_parameter_declarations:
        HashMap<lower::Path, util::WithInfo<typecheck::TypeParameterDeclaration>>,

    /// The language declarations in the program.
    pub language_declarations: HashMap<String, Vec<lower::Path>>,

    /// The constant declarations in the program.
    pub constant_declarations: HashMap<lower::Path, util::WithInfo<typecheck::ConstantDeclaration>>,

    /// The instance declarations in the program.
    pub instance_declarations: HashMap<lower::Path, util::WithInfo<typecheck::InstanceDeclaration>>,
}

impl Extend<Self> for Interface {
    fn extend<T: IntoIterator<Item = Self>>(&mut self, iter: T) {
        for interface in iter {
            self.files.extend(interface.files);
            self.top_level.extend(interface.top_level);
            self.syntax_declarations
                .extend(interface.syntax_declarations);
            self.type_declarations.extend(interface.type_declarations);
            self.trait_declarations.extend(interface.trait_declarations);
            self.type_parameter_declarations
                .extend(interface.type_parameter_declarations);
            self.constant_declarations
                .extend(interface.constant_declarations);
            self.instance_declarations
                .extend(interface.instance_declarations);

            for (name, paths) in interface.language_declarations {
                self.language_declarations
                    .entry(name)
                    .or_default()
                    .extend(paths);
            }
        }
    }
}

/// Diagnostics produced by the compiler.
#[derive(Debug)]
pub enum Diagnostic {
    Tokenize(syntax::tokenize::Diagnostic),
    Parse(syntax::parse::Diagnostic),
    Syntax(syntax::Diagnostic),
    Lower(lower::Diagnostic),
    Typecheck(typecheck::Diagnostic),
    Ir,
}

impl Driver {
    /// Compile a set of source files into a [`Library`] and [`Interface`].
    pub fn compile(&mut self, files: Vec<File>) -> Vec<util::WithInfo<Diagnostic>> {
        let mut diagnostics = Vec::new();

        self.interface.files.extend(files.clone());

        let files = files.into_iter().filter_map(|file| {
            let (tokens, tokenize_diagnostics): (Vec<_>, Vec<_>) =
                syntax::tokenize::tokenize(&file.path, &file.code).partition_result();

            diagnostics.extend(
                tokenize_diagnostics
                    .into_iter()
                    .map(|diagnostic| diagnostic.map(Diagnostic::Tokenize)),
            );

            let logical_tokens = syntax::tokenize::to_logical_lines(tokens);

            let (tree, tokenize_diagnostics) =
                syntax::tokenize::TokenTree::from_top_level(logical_tokens)?;

            diagnostics.extend(
                tokenize_diagnostics
                    .into_iter()
                    .map(|diagnostic| diagnostic.map(Diagnostic::Tokenize)),
            );

            let parse_result = syntax::parse::parse_top_level(tree.as_ref());

            diagnostics.extend(
                parse_result
                    .diagnostics
                    .into_iter()
                    .map(|error| error.map(Diagnostic::Parse)),
            );

            let syntax_result = syntax::parse(parse_result.parsed);

            diagnostics.extend(
                syntax_result
                    .diagnostics
                    .into_iter()
                    .map(|diagnostic| diagnostic.map(Diagnostic::Syntax)),
            );

            Some(convert::lower::convert(file.path, syntax_result.top_level))
        });

        let interface = self.interface.clone();

        let lower_result = crate::lower::resolve(
            files,
            lower::Interface {
                top_level: interface.top_level,
                syntax_declarations: interface
                    .syntax_declarations
                    .into_iter()
                    .map(|(name, item)| {
                        (name, convert::interface::convert_syntax_declaration(item))
                    })
                    .collect(),
                type_declarations: interface
                    .type_declarations
                    .into_iter()
                    .map(|(path, item)| (path, convert::interface::convert_type_declaration(item)))
                    .collect(),
                trait_declarations: interface
                    .trait_declarations
                    .into_iter()
                    .map(|(path, item)| (path, convert::interface::convert_trait_declaration(item)))
                    .collect(),
                type_parameter_declarations: interface
                    .type_parameter_declarations
                    .into_iter()
                    .map(|(path, item)| {
                        (
                            path,
                            convert::interface::convert_type_parameter_declaration(item),
                        )
                    })
                    .collect(),
                language_declarations: interface.language_declarations,
                constant_declarations: interface
                    .constant_declarations
                    .into_iter()
                    .map(|(path, item)| {
                        (path, convert::interface::convert_constant_declaration(item))
                    })
                    .collect(),
                instance_declarations: interface
                    .instance_declarations
                    .into_iter()
                    .map(|(path, item)| {
                        (path, convert::interface::convert_instance_declaration(item))
                    })
                    .collect(),
            },
        );

        diagnostics.extend(
            lower_result
                .diagnostics
                .into_iter()
                .map(|error| error.map(Diagnostic::Lower)),
        );

        for (name, items) in lower_result.interface.top_level {
            self.interface
                .top_level
                .entry(name)
                .or_default()
                .extend(items);
        }

        for (path, item) in lower_result.interface.syntax_declarations {
            let declaration = convert::typecheck::convert_syntax_declaration(item);
            self.interface.syntax_declarations.insert(path, declaration);
        }

        for (path, item) in lower_result.interface.type_declarations {
            let declaration = convert::typecheck::convert_type_declaration(item);
            self.interface.type_declarations.insert(path, declaration);
        }

        for (path, item) in lower_result.interface.trait_declarations {
            let declaration = convert::typecheck::convert_trait_declaration(item);
            self.interface.trait_declarations.insert(path, declaration);
        }

        for (path, item) in lower_result.interface.type_parameter_declarations {
            let declaration = convert::typecheck::convert_type_parameter_declaration(item);
            self.interface
                .type_parameter_declarations
                .insert(path, declaration);
        }

        for (name, paths) in lower_result.interface.language_declarations {
            self.interface
                .language_declarations
                .entry(name)
                .or_default()
                .extend(paths);
        }

        for (path, item) in &lower_result.interface.constant_declarations {
            let declaration = convert::typecheck::convert_constant_declaration(item.clone());

            self.interface
                .constant_declarations
                .insert(path.clone(), declaration);
        }

        for (path, item) in &lower_result.interface.instance_declarations {
            let declaration = convert::typecheck::convert_instance_declaration(item.clone());

            self.interface
                .instance_declarations
                .insert(path.clone(), declaration);
        }

        for (path, declaration) in lower_result.interface.constant_declarations {
            let item = match lower_result
                .library
                .items
                .get(&path)
                // Constants always have values; skip ones that somehow don't...
                .and_then(|item| item.as_ref())
            {
                Some(item) => item.clone(),
                None => continue, // ...here
            };

            let declaration = convert::typecheck::convert_constant_declaration(declaration);

            let typecheck_result = crate::typecheck::resolve(
                self,
                (declaration.clone(), convert::typecheck::convert_item(item)),
            );

            let item = match typecheck_result.item {
                Some(item) => item,
                None => continue,
            };

            diagnostics.extend(
                typecheck_result
                    .diagnostics
                    .into_iter()
                    .map(|error| error.map(Diagnostic::Typecheck)),
            );

            let exhaustiveness_diagnostics =
                crate::typecheck::check_exhaustiveness(self, item.as_ref());

            diagnostics.extend(
                exhaustiveness_diagnostics
                    .into_iter()
                    .map(|error| error.map(Diagnostic::Typecheck)),
            );

            self.items.insert(path, item);
        }

        for (path, declaration) in lower_result.interface.instance_declarations {
            let item = match lower_result.library.items.get(&path) {
                Some(item) => item.clone(),
                None => {
                    // `None` here means that the implementation is in a
                    // different library; skip it
                    continue;
                }
            };

            let declaration = convert::typecheck::convert_instance_declaration(declaration);

            let typecheck_result = crate::typecheck::resolve(
                self,
                (
                    declaration.clone(),
                    item.map(convert::typecheck::convert_item),
                ),
            );

            let item = match typecheck_result.item {
                Some(item) => item,
                None => continue,
            };

            diagnostics.extend(
                typecheck_result
                    .diagnostics
                    .into_iter()
                    .map(|error| error.map(Diagnostic::Typecheck)),
            );

            let exhaustiveness_diagnostics =
                crate::typecheck::check_exhaustiveness(self, item.as_ref());

            diagnostics.extend(
                exhaustiveness_diagnostics
                    .into_iter()
                    .map(|error| error.map(Diagnostic::Typecheck)),
            );

            self.items.insert(path, item);
        }

        for (path, top_level_code) in lower_result.library.code {
            let typecheck_result = crate::typecheck::resolve(
                self,
                convert::typecheck::convert_top_level_code(top_level_code),
            );

            if let Some(item) = typecheck_result.item {
                diagnostics.extend(
                    typecheck_result
                        .diagnostics
                        .into_iter()
                        .map(|error| error.map(Diagnostic::Typecheck)),
                );

                let exhaustiveness_diagnostics =
                    crate::typecheck::check_exhaustiveness(self, item.as_ref());

                diagnostics.extend(
                    exhaustiveness_diagnostics
                        .into_iter()
                        .map(|error| error.map(Diagnostic::Typecheck)),
                );

                self.entrypoint = Some(path.clone());
                self.items.insert(path, item);
            }
        }

        let instances_by_trait = self
            .interface
            .instance_declarations
            .iter()
            .map(|(path, instance)| {
                (
                    instance.item.instance.item.r#trait.clone(),
                    (path, instance),
                )
            })
            .into_group_map_by(|(r#trait, _)| r#trait.clone());

        for (r#trait, instances) in instances_by_trait {
            let (default_instances, non_default_instances): (Vec<_>, Vec<_>) = instances
                .into_iter()
                .partition(|&(_, (_, instance))| instance.item.default);

            for instances in [default_instances, non_default_instances] {
                let overlap_diagnostics = typecheck::instances_overlap(
                    self,
                    &r#trait,
                    instances
                        .into_iter()
                        .map(|(_, (path, _))| path.clone())
                        .collect(),
                );

                diagnostics.extend(
                    overlap_diagnostics
                        .into_iter()
                        .map(|error| error.map(Diagnostic::Typecheck)),
                );
            }
        }

        diagnostics
    }

    /// Resolve an attribute-like trait, where the first parameter is the provided
    /// type and the remaining parameters are returned.
    pub fn resolve_attribute_like_trait(
        &self,
        name: &str,
        r#type: util::WithInfo<typecheck::Type>,
        number_of_parameters: u32,
    ) -> Option<Vec<util::WithInfo<typecheck::Type>>> {
        typecheck::resolve_attribute_like_trait(self, name, r#type.as_ref(), number_of_parameters)
    }

    /// Check if the provided declared type path represents a language item.
    pub fn type_is_language_item(&self, path: &crate::lower::Path, language_item: &str) -> bool {
        use crate::typecheck::Driver as _;

        self.path_for_language_type(language_item)
            .is_some_and(|item| item == *path)
    }

    pub fn executable(&self) -> Result<Executable, ()> {
        let mut codegen = Codegen::new(self);

        let entrypoint = self.entrypoint.as_ref().ok_or(())?;
        codegen.insert_item(entrypoint)?;

        // Loop because `insert_instance` may reference additional traits whose
        // instances must also be inserted
        loop {
            let mut progress = false;
            for (path, instance) in &self.interface.instance_declarations {
                if codegen.references_trait(&instance.item.instance.item.r#trait) {
                    if self.items.contains_key(path) {
                        let inserted = codegen.insert_instance(path, instance.as_ref())?;
                        progress |= inserted;
                    } else {
                        // Instance for marker trait; will never be executed at runtime
                    }
                }
            }

            if !progress {
                break;
            }
        }

        Ok(codegen.into_executable(entrypoint))
    }
}

macro_rules! path_for_language {
    ($kind:ident, $self:expr, $language_item:expr) => {
        $self
            .interface
            .language_declarations
            .get($language_item)
            .and_then(|declarations| {
                declarations
                    .iter()
                    .find(|path| matches!(path.last().unwrap(), lower::PathComponent::$kind(_)))
                    .cloned()
            })
    };
}

impl crate::typecheck::Driver for Driver {
    fn recursion_limit(&self) -> u32 {
        self.recursion_limit
    }

    fn top_level_info(&self) -> Location {
        syntax::Location {
            path: Arc::from("top-level"),
            span: 0..0,
        }
    }

    fn path_for_language_type(&self, language_item: &str) -> Option<Path> {
        path_for_language!(Type, self, language_item)
    }

    fn path_for_language_trait(&self, language_item: &str) -> Option<Path> {
        path_for_language!(Trait, self, language_item)
    }

    fn path_for_language_constructor(&self, language_item: &str) -> Option<Path> {
        path_for_language!(Constructor, self, language_item)
    }

    fn path_for_language_constant(&self, language_item: &str) -> Option<Path> {
        path_for_language!(Constant, self, language_item)
    }

    fn paths_are_equal(&self, left: &Path, right: &Path) -> bool {
        left == right
    }

    fn get_type_declaration(
        &self,
        path: &Path,
    ) -> util::WithInfo<crate::typecheck::TypeDeclaration> {
        self.interface
            .type_declarations
            .get(path)
            .cloned()
            .unwrap_or_else(|| panic!("missing type declaration {:?}", path))
    }

    fn get_trait_declaration(
        &self,
        path: &Path,
    ) -> util::WithInfo<crate::typecheck::TraitDeclaration> {
        self.interface
            .trait_declarations
            .get(path)
            .cloned()
            .unwrap_or_else(|| panic!("missing trait declaration {:?}", path))
    }

    fn get_type_parameter_declaration(
        &self,
        path: &Path,
    ) -> util::WithInfo<crate::typecheck::TypeParameterDeclaration> {
        self.interface
            .type_parameter_declarations
            .get(path)
            .cloned()
            .unwrap_or_else(|| panic!("missing type parameter declaration {:?}", path))
    }

    fn get_constant_declaration(
        &self,
        path: &Path,
    ) -> util::WithInfo<crate::typecheck::ConstantDeclaration> {
        self.interface
            .constant_declarations
            .get(path)
            .cloned()
            .unwrap_or_else(|| panic!("missing constant declaration {:?}", path))
    }

    fn get_instance_declaration(
        &self,
        path: &Path,
    ) -> util::WithInfo<crate::typecheck::InstanceDeclaration> {
        self.interface
            .instance_declarations
            .get(path)
            .cloned()
            .unwrap_or_else(|| panic!("missing instance declaration {:?}", path))
    }

    fn get_instances_for_trait(&self, r#trait: &Path) -> Vec<Path> {
        [&self.interface]
            .into_iter()
            .flat_map(|interface| &interface.instance_declarations)
            .filter(|(_, instance)| instance.item.instance.item.r#trait == *r#trait)
            .map(|(path, _)| path.clone())
            .collect()
    }

    fn get_enumeration_for_variant(&self, variant: &Path) -> Path {
        // The parent of a variant is its enumeration
        lower::Path(variant[0..variant.len() - 1].to_vec())
    }

    fn get_item_body(&self, path: &Path) -> util::WithInfo<&typecheck::TypedExpression> {
        self.items
            .get(path)
            .unwrap_or_else(|| panic!("missing item {:?}", path))
            .as_ref()
    }
}
