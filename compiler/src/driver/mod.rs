//! Coordinates the compiler passes.

mod convert;

use crate::{
    ir,
    lower::{self, Path},
    syntax::{self, Location},
    typecheck, util,
};
use itertools::Itertools;
use serde::{Deserialize, Serialize};
use std::{
    collections::{HashMap, HashSet},
    sync::Arc,
};
use typeshare::typeshare;

/// The default recursion limit.
// TODO: Make this configurable
pub const DEFAULT_RECURSION_LIMIT: u32 = 64;

/// The driver.
#[non_exhaustive]
#[derive(Debug, Clone)]
pub struct Driver {
    recursion_limit: u32,
    pub(crate) interface: Interface,
    executable: Executable,
}

impl Driver {
    pub fn new() -> Self {
        Driver {
            recursion_limit: DEFAULT_RECURSION_LIMIT,
            interface: Default::default(),
            executable: Default::default(),
        }
    }
}

impl Driver {
    pub fn format(code: &str) -> String {
        match syntax::tokenize::tokenize("format", code).collect::<std::result::Result<Vec<_>, _>>()
        {
            Ok(tokens) => {
                syntax::tokenize::format(tokens.iter().map(|token| &token.item).collect())
            }
            Err(_) => code.to_string(),
        }
    }
}

/// A file provided to [`Driver::compile`].
#[derive(Debug, Clone, Deserialize)]
pub struct File {
    /// The file's path.
    pub path: String,

    /// The file's contents.
    pub code: String,
}

/// An interface generated by the compiler.
#[non_exhaustive]
#[derive(Debug, Clone, Default)]
pub struct Interface {
    /// The files used during compilation. Not all files may be available.
    pub files: Vec<File>,

    /// The names of top-level declarations in the program.
    pub top_level: HashMap<String, Vec<util::WithInfo<lower::Path>>>,

    /// The syntax declarations in the program.
    pub syntax_declarations: HashMap<lower::Path, util::WithInfo<typecheck::SyntaxDeclaration>>,

    /// The type declarations in the program.
    pub type_declarations: HashMap<lower::Path, util::WithInfo<typecheck::TypeDeclaration>>,

    /// The trait declarations in the program.
    pub trait_declarations: HashMap<lower::Path, util::WithInfo<typecheck::TraitDeclaration>>,

    /// The type parameters in the program.
    pub type_parameter_declarations:
        HashMap<lower::Path, util::WithInfo<typecheck::TypeParameterDeclaration>>,

    /// The language declarations in the program.
    pub language_declarations: HashMap<String, Vec<lower::Path>>,

    /// The constant declarations in the program.
    pub constant_declarations: HashMap<lower::Path, util::WithInfo<typecheck::ConstantDeclaration>>,

    /// The instance declarations in the program.
    pub instance_declarations: HashMap<lower::Path, util::WithInfo<typecheck::InstanceDeclaration>>,
}

impl Extend<Self> for Interface {
    fn extend<T: IntoIterator<Item = Self>>(&mut self, iter: T) {
        for interface in iter {
            self.files.extend(interface.files);
            self.top_level.extend(interface.top_level);
            self.syntax_declarations
                .extend(interface.syntax_declarations);
            self.type_declarations.extend(interface.type_declarations);
            self.trait_declarations.extend(interface.trait_declarations);
            self.type_parameter_declarations
                .extend(interface.type_parameter_declarations);
            self.constant_declarations
                .extend(interface.constant_declarations);
            self.instance_declarations
                .extend(interface.instance_declarations);

            for (name, paths) in interface.language_declarations {
                self.language_declarations
                    .entry(name)
                    .or_default()
                    .extend(paths);
            }
        }
    }
}

/// A linked executable.
#[non_exhaustive]
#[typeshare]
#[derive(Debug, Clone, Default, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct Executable {
    /// The implementations of constants and instances.
    pub items: HashMap<Path, Item>,

    /// The layouts of each declared type.
    pub layouts: HashMap<Path, crate::ir::LayoutDescriptor>,

    /// The list of instances for each trait.
    pub instances: HashMap<Path, HashMap<Path, Instance>>,

    /// The default instances for each trait.
    pub default_instances: HashMap<Path, HashMap<Path, Instance>>,

    /// The item to run when the program starts.
    pub entrypoint: Option<Path>,

    /// Items exported by the executable.
    pub exports: HashMap<String, Path>,
}

/// An analyzed instance.
#[typeshare]
#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct Instance {
    /// The path to the associated [`UnlinkedItem`].
    pub path: Path,

    /// The list of parameters the instance provides to the trait.
    pub trait_parameters: Vec<InstanceTraitParameter>,
}

/// A parameter an instance provides to a trait.
#[typeshare]
#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct InstanceTraitParameter {
    /// The path of the parameter as defined in the trait.
    pub path: Path,

    /// The type descriptor of the type provided for this parameter.
    pub type_descriptor: crate::ir::TypeDescriptor,
}

/// An analyzed expression along with its compiled IR.
#[typeshare]
#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct Item {
    /// The list of type parameters declared by the item.
    pub parameters: Vec<Path>,

    /// The list of bounds required by this item.
    pub bounds: Vec<crate::ir::InstanceDescriptor>,

    /// The compiled IR.
    pub ir: Vec<crate::ir::Instruction>,
}

/// The result of [`Driver::compile`].
#[derive(Debug)]
pub struct Result {
    /// Any diagnostics ocurring during compilation.
    pub diagnostics: Vec<util::WithInfo<Diagnostic>>,
}

/// Diagnostics produced by the compiler.
#[derive(Debug)]
pub enum Diagnostic {
    Tokenize(syntax::tokenize::Diagnostic),
    Parse(syntax::parse::Diagnostic),
    Syntax(syntax::Diagnostic),
    Lower(lower::Diagnostic),
    Typecheck(typecheck::Diagnostic),
    Ir,
}

impl Driver {
    /// Compile a set of source files into a [`Library`] and [`Interface`].
    pub fn compile(&mut self, files: Vec<File>) -> Result {
        let mut diagnostics = Vec::new();

        self.interface.files.extend(files.clone());

        let files = files.into_iter().filter_map(|file| {
            let (tokens, tokenize_diagnostics): (Vec<_>, Vec<_>) =
                syntax::tokenize::tokenize(&file.path, &file.code).partition_result();

            diagnostics.extend(
                tokenize_diagnostics
                    .into_iter()
                    .map(|diagnostic| diagnostic.map(Diagnostic::Tokenize)),
            );

            let logical_tokens = syntax::tokenize::to_logical_lines(tokens);

            let (tree, tokenize_diagnostics) =
                syntax::tokenize::TokenTree::from_top_level(logical_tokens)?;

            diagnostics.extend(
                tokenize_diagnostics
                    .into_iter()
                    .map(|diagnostic| diagnostic.map(Diagnostic::Tokenize)),
            );

            let parse_result = syntax::parse::parse_top_level(tree.as_ref());

            diagnostics.extend(
                parse_result
                    .diagnostics
                    .into_iter()
                    .map(|error| error.map(Diagnostic::Parse)),
            );

            let syntax_result = syntax::parse(parse_result.parsed);

            diagnostics.extend(
                syntax_result
                    .diagnostics
                    .into_iter()
                    .map(|diagnostic| diagnostic.map(Diagnostic::Syntax)),
            );

            Some(convert::lower::convert(file.path, syntax_result.top_level))
        });

        let interface = self.interface.clone();

        let lower_result = crate::lower::resolve(
            files,
            lower::Interface {
                top_level: interface.top_level,
                syntax_declarations: interface
                    .syntax_declarations
                    .into_iter()
                    .map(|(name, item)| {
                        (name, convert::interface::convert_syntax_declaration(item))
                    })
                    .collect(),
                type_declarations: interface
                    .type_declarations
                    .into_iter()
                    .map(|(path, item)| (path, convert::interface::convert_type_declaration(item)))
                    .collect(),
                trait_declarations: interface
                    .trait_declarations
                    .into_iter()
                    .map(|(path, item)| (path, convert::interface::convert_trait_declaration(item)))
                    .collect(),
                type_parameter_declarations: interface
                    .type_parameter_declarations
                    .into_iter()
                    .map(|(path, item)| {
                        (
                            path,
                            convert::interface::convert_type_parameter_declaration(item),
                        )
                    })
                    .collect(),
                language_declarations: interface.language_declarations,
                constant_declarations: interface
                    .constant_declarations
                    .into_iter()
                    .map(|(path, item)| {
                        (path, convert::interface::convert_constant_declaration(item))
                    })
                    .collect(),
                instance_declarations: interface
                    .instance_declarations
                    .into_iter()
                    .map(|(path, item)| {
                        (path, convert::interface::convert_instance_declaration(item))
                    })
                    .collect(),
            },
        );

        diagnostics.extend(
            lower_result
                .diagnostics
                .into_iter()
                .map(|error| error.map(Diagnostic::Lower)),
        );

        for (name, items) in lower_result.interface.top_level {
            self.interface
                .top_level
                .entry(name)
                .or_default()
                .extend(items);
        }

        for (path, item) in lower_result.interface.syntax_declarations {
            let declaration = convert::typecheck::convert_syntax_declaration(item);
            self.interface.syntax_declarations.insert(path, declaration);
        }

        for (path, item) in lower_result.interface.type_declarations {
            let declaration = convert::typecheck::convert_type_declaration(item);
            self.interface.type_declarations.insert(path, declaration);
        }

        for (path, item) in lower_result.interface.trait_declarations {
            let declaration = convert::typecheck::convert_trait_declaration(item);
            self.interface.trait_declarations.insert(path, declaration);
        }

        for (path, item) in lower_result.interface.type_parameter_declarations {
            let declaration = convert::typecheck::convert_type_parameter_declaration(item);
            self.interface
                .type_parameter_declarations
                .insert(path, declaration);
        }

        for (name, paths) in lower_result.interface.language_declarations {
            self.interface
                .language_declarations
                .entry(name)
                .or_default()
                .extend(paths);
        }

        for (path, item) in &lower_result.interface.constant_declarations {
            let declaration = convert::typecheck::convert_constant_declaration(item.clone());

            self.interface
                .constant_declarations
                .insert(path.clone(), declaration);
        }

        for (path, item) in &lower_result.interface.instance_declarations {
            let declaration = convert::typecheck::convert_instance_declaration(item.clone());

            self.interface
                .instance_declarations
                .insert(path.clone(), declaration);
        }

        for (path, declaration) in lower_result.interface.constant_declarations {
            let item = match lower_result
                .library
                .items
                .get(&path)
                // Constants always have values; skip ones that somehow don't...
                .and_then(|item| item.as_ref())
            {
                Some(item) => item.clone(),
                None => continue, // ...here
            };

            let declaration = convert::typecheck::convert_constant_declaration(declaration);

            let typecheck_result = crate::typecheck::resolve(
                self,
                (declaration.clone(), convert::typecheck::convert_item(item)),
            );

            let item = match typecheck_result.item {
                Some(item) => item,
                None => continue,
            };

            diagnostics.extend(
                typecheck_result
                    .diagnostics
                    .into_iter()
                    .map(|error| error.map(Diagnostic::Typecheck)),
            );

            let exhaustiveness_diagnostics =
                crate::typecheck::check_exhaustiveness(self, item.as_ref());

            diagnostics.extend(
                exhaustiveness_diagnostics
                    .into_iter()
                    .map(|error| error.map(Diagnostic::Typecheck)),
            );

            let ir_result = ir::compile(
                self,
                path.clone(),
                &declaration.item.attributes,
                item.as_ref(),
                &typecheck_result.captures,
            );

            for (path, item) in ir_result.items {
                self.executable.items.insert(
                    path,
                    Item {
                        parameters: declaration.item.parameters.clone(),
                        bounds: declaration
                            .item
                            .bounds
                            .clone()
                            .into_iter()
                            .filter_map(|bound| ir::instance_descriptor(&bound.item))
                            .collect(),
                        ir: item.instructions,
                    },
                );
            }
        }

        for (path, declaration) in lower_result.interface.instance_declarations {
            let item = match lower_result.library.items.get(&path) {
                Some(item) => item.clone(),
                None => {
                    // `None` here means that the implementation is in a
                    // different library; skip it
                    continue;
                }
            };

            let declaration = convert::typecheck::convert_instance_declaration(declaration);

            let typecheck_result = crate::typecheck::resolve(
                self,
                (
                    declaration.clone(),
                    item.map(convert::typecheck::convert_item),
                ),
            );

            let item = match typecheck_result.item {
                Some(item) => item,
                None => continue,
            };

            diagnostics.extend(
                typecheck_result
                    .diagnostics
                    .into_iter()
                    .map(|error| error.map(Diagnostic::Typecheck)),
            );

            let exhaustiveness_diagnostics =
                crate::typecheck::check_exhaustiveness(self, item.as_ref());

            diagnostics.extend(
                exhaustiveness_diagnostics
                    .into_iter()
                    .map(|error| error.map(Diagnostic::Typecheck)),
            );

            let ir_result = ir::compile(
                self,
                path.clone(),
                &[],
                item.as_ref(),
                &typecheck_result.captures,
            );

            for (path, item) in ir_result.items {
                self.executable.items.insert(
                    path,
                    Item {
                        parameters: declaration.item.parameters.clone(),
                        bounds: declaration
                            .item
                            .bounds
                            .clone()
                            .into_iter()
                            .filter_map(|bound| ir::instance_descriptor(&bound.item))
                            .collect(),
                        ir: item.instructions,
                    },
                );
            }
        }

        for (path, top_level_code) in lower_result.library.code {
            let typecheck_result = crate::typecheck::resolve(
                self,
                convert::typecheck::convert_top_level_code(top_level_code),
            );

            if let Some(item) = typecheck_result.item {
                diagnostics.extend(
                    typecheck_result
                        .diagnostics
                        .into_iter()
                        .map(|error| error.map(Diagnostic::Typecheck)),
                );

                let exhaustiveness_diagnostics =
                    crate::typecheck::check_exhaustiveness(self, item.as_ref());

                diagnostics.extend(
                    exhaustiveness_diagnostics
                        .into_iter()
                        .map(|error| error.map(Diagnostic::Typecheck)),
                );

                let ir_result = ir::compile(
                    self,
                    path.clone(),
                    &[],
                    item.as_ref(),
                    &typecheck_result.captures,
                );

                for (path, item) in ir_result.items {
                    self.executable.items.insert(
                        path,
                        Item {
                            parameters: Vec::new(),
                            bounds: Vec::new(),
                            ir: item.instructions,
                        },
                    );
                }

                self.executable.entrypoint = Some(path);
            }
        }

        for (path, type_declaration) in &self.interface.type_declarations {
            if let Some(layout) = ir::layout_descriptor(&type_declaration.item) {
                self.executable.layouts.insert(path.clone(), layout);
            }
        }

        let instances_by_trait = self
            .interface
            .instance_declarations
            .iter()
            .into_group_map_by(|(_, instance)| instance.item.instance.item.r#trait.clone());

        for (r#trait, instances) in instances_by_trait {
            let trait_declaration = typecheck::Driver::get_trait_declaration(self, &r#trait);

            let mut default_instances = HashSet::new();
            let instances = instances
                .into_iter()
                .filter_map(|(path, declaration)| {
                    if declaration.item.default {
                        default_instances.insert(path.clone());
                    }

                    Some(Instance {
                        path: path.clone(),
                        trait_parameters: trait_declaration
                            .item
                            .parameters
                            .clone()
                            .into_iter()
                            .zip(declaration.item.instance.item.parameters.clone())
                            .map(|(path, r#type)| {
                                Some(InstanceTraitParameter {
                                    path,
                                    type_descriptor: ir::type_descriptor(&r#type.item)?,
                                })
                            })
                            .collect::<Option<_>>()?,
                    })
                })
                .collect::<Vec<_>>();

            let overlap_diagnostics = typecheck::instances_overlap(
                self,
                &r#trait,
                instances
                    .iter()
                    .map(|instance| instance.path.clone())
                    .collect(),
            );

            diagnostics.extend(
                overlap_diagnostics
                    .into_iter()
                    .map(|error| error.map(Diagnostic::Typecheck)),
            );

            for instance in instances {
                let instances = if default_instances.contains(&instance.path) {
                    &mut self.executable.default_instances
                } else {
                    &mut self.executable.instances
                };

                instances
                    .entry(r#trait.clone())
                    .or_default()
                    .insert(instance.path.clone(), instance);
            }
        }

        Result { diagnostics }
    }

    /// Resolve an attribute-like trait, where the first parameter is the provided
    /// type and the remaining parameters are returned.
    pub fn resolve_attribute_like_trait(
        &self,
        name: &str,
        r#type: util::WithInfo<typecheck::Type>,
        number_of_parameters: u32,
    ) -> Option<Vec<util::WithInfo<typecheck::Type>>> {
        typecheck::resolve_attribute_like_trait(self, name, r#type.as_ref(), number_of_parameters)
    }

    /// Check if the provided declared type path represents a language item.
    pub fn type_is_language_item(&self, path: &crate::lower::Path, language_item: &str) -> bool {
        use crate::typecheck::Driver as _;

        self.path_for_language_type(language_item)
            .is_some_and(|item| item == *path)
    }

    pub fn executable(&self) -> Executable {
        self.executable.clone()
    }
}

macro_rules! path_for_language {
    ($kind:ident, $self:expr, $language_item:expr) => {
        $self
            .interface
            .language_declarations
            .get($language_item)
            .and_then(|declarations| {
                declarations
                    .iter()
                    .find(|path| matches!(path.last().unwrap(), lower::PathComponent::$kind(_)))
                    .cloned()
            })
    };
}

impl crate::typecheck::Driver for Driver {
    fn recursion_limit(&self) -> u32 {
        self.recursion_limit
    }

    fn top_level_info(&self) -> Location {
        syntax::Location {
            path: Arc::from("top-level"),
            span: 0..0,
        }
    }

    fn path_for_language_type(&self, language_item: &str) -> Option<Path> {
        path_for_language!(Type, self, language_item)
    }

    fn path_for_language_trait(&self, language_item: &str) -> Option<Path> {
        path_for_language!(Trait, self, language_item)
    }

    fn path_for_language_constructor(&self, language_item: &str) -> Option<Path> {
        path_for_language!(Constructor, self, language_item)
    }

    fn path_for_language_constant(&self, language_item: &str) -> Option<Path> {
        path_for_language!(Constant, self, language_item)
    }

    fn paths_are_equal(&self, left: &Path, right: &Path) -> bool {
        left == right
    }

    fn get_type_declaration(
        &self,
        path: &Path,
    ) -> util::WithInfo<crate::typecheck::TypeDeclaration> {
        self.interface
            .type_declarations
            .get(path)
            .cloned()
            .unwrap_or_else(|| panic!("missing type declaration {:?}", path))
    }

    fn get_trait_declaration(
        &self,
        path: &Path,
    ) -> util::WithInfo<crate::typecheck::TraitDeclaration> {
        self.interface
            .trait_declarations
            .get(path)
            .cloned()
            .unwrap_or_else(|| panic!("missing trait declaration {:?}", path))
    }

    fn get_type_parameter_declaration(
        &self,
        path: &Path,
    ) -> util::WithInfo<crate::typecheck::TypeParameterDeclaration> {
        self.interface
            .type_parameter_declarations
            .get(path)
            .cloned()
            .unwrap_or_else(|| panic!("missing type parameter declaration {:?}", path))
    }

    fn get_constant_declaration(
        &self,
        path: &Path,
    ) -> util::WithInfo<crate::typecheck::ConstantDeclaration> {
        self.interface
            .constant_declarations
            .get(path)
            .cloned()
            .unwrap_or_else(|| panic!("missing constant declaration {:?}", path))
    }

    fn get_instance_declaration(
        &self,
        path: &Path,
    ) -> util::WithInfo<crate::typecheck::InstanceDeclaration> {
        self.interface
            .instance_declarations
            .get(path)
            .cloned()
            .unwrap_or_else(|| panic!("missing instance declaration {:?}", path))
    }

    fn get_instances_for_trait(&self, r#trait: &Path) -> Vec<Path> {
        [&self.interface]
            .into_iter()
            .flat_map(|interface| &interface.instance_declarations)
            .filter(|(_, instance)| instance.item.instance.item.r#trait == *r#trait)
            .map(|(path, _)| path.clone())
            .collect()
    }

    fn get_enumeration_for_variant(&self, variant: &Path) -> Path {
        // The parent of a variant is its enumeration
        lower::Path(variant[0..variant.len() - 1].to_vec())
    }
}

impl crate::ir::Driver for Driver {
    fn number_type(&self) -> Option<Path> {
        [&self.interface]
            .into_iter()
            .filter_map(|interface| interface.language_declarations.get("number"))
            .flatten()
            .find(|path| matches!(path.last().unwrap(), lower::PathComponent::Type(_)))
            .cloned()
    }

    fn text_type(&self) -> Option<Path> {
        [&self.interface]
            .into_iter()
            .filter_map(|interface| interface.language_declarations.get("text"))
            .flatten()
            .find(|path| matches!(path.last().unwrap(), lower::PathComponent::Type(_)))
            .cloned()
    }

    fn boolean_type(&self) -> Option<Path> {
        [&self.interface]
            .into_iter()
            .filter_map(|interface| interface.language_declarations.get("boolean"))
            .flatten()
            .find(|path| matches!(path.last().unwrap(), lower::PathComponent::Type(_)))
            .cloned()
    }

    fn true_variant(&self) -> Option<Path> {
        [&self.interface]
            .into_iter()
            .filter_map(|interface| interface.language_declarations.get("true"))
            .flatten()
            .find(|path| matches!(path.last().unwrap(), lower::PathComponent::Constructor(_)))
            .cloned()
            .map(variant_from_constructor)
    }

    fn number_equality_intrinsic(&self) -> Option<String> {
        Some(String::from("number-equality"))
    }

    fn text_equality_intrinsic(&self) -> Option<String> {
        Some(String::from("text-equality"))
    }

    fn item_path_in(&self, path: &Path, index: u32) -> Path {
        path.join(lower::PathComponent::Item(index))
    }
}

fn variant_from_constructor(mut path: lower::Path) -> lower::Path {
    let name = match path.pop().unwrap() {
        lower::PathComponent::Constructor(name) => name,
        _ => panic!("expected constructor"),
    };

    path.push(lower::PathComponent::Variant(name));

    path
}
