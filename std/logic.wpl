[[no-std]]

[language "boolean"]
[help "Represents either `True` or `False`."]
[help-group "Logic"]
Boolean : type {
  False
  True
}

[help "Choose between two values depending on whether the input is `True` or `False`."]
[help-group "Control Flow"]
[keyword]
if : syntax {
  if 'bool 'then 'else -> when 'bool {
    True -> 'then
    False -> 'else
  }
  if 'bool 'then -> if 'bool 'then ()
}

[help "Represents the logical inverse of a value."]
[help-group "Logic"]
Not : (A : Boolean) => trait (A -> A)

instance (Not Boolean) : bool -> if bool False True
A B where (Not B) => instance (Not (A -> B)) : f x -> not (f x)

[help "Returns `False` if provided `True`, and vice versa. Can also be used on boolean functions and any other value that implements `Not`."]
[help-group "Logic"]
not :: A where (Not A) => A -> A
not : Not

And : Left Right (infer Output) => trait ((() -> Right) -> Left -> Output)

[help "Returns `True` if both sides are `True`."]
[help-group "Logic"]
[operator Conjunction-Precedence]
and : syntax {
  'a and 'b -> And (() -> 'b) 'a
  'a and -> b -> And b 'a
  and 'b -> And (() -> 'b)
  and -> And
}

instance (And Boolean Boolean Boolean) : b a -> if a (b ()) False

Or : Left Right (infer Output) => trait ((() -> Right) -> Left -> Output)

[help "Returns `True` if either side is `True`."]
[help-group "Logic"]
[operator Disjunction-Precedence]
or : syntax {
  'a or 'b -> Or (() -> 'b) 'a
  'a or -> b -> Or b 'a
  or 'b -> Or (() -> 'b)
  or -> Or
}

instance (Or Boolean Boolean Boolean) : b a -> if a True (b ())

[help "The result of a comparison between two values."]
[help-group "Logic"]
Ordering : type {
  Less
  Equal
  Greater
}

[help "Implement this trait to enable comparisons between two values of your type."]
[help-group "Logic"]
Order : A => trait (A -> A -> Ordering)

instance (Order Number) : b a -> intrinsic "number-ordering" a b
instance (Order Integer) : b a -> intrinsic "integer-ordering" a b
instance (Order Natural) : b a -> intrinsic "natural-ordering" a b
instance (Order Byte) : b a -> intrinsic "byte-ordering" a b
instance (Order Signed) : b a -> intrinsic "signed-ordering" a b
instance (Order Unsigned) : b a -> intrinsic "unsigned-ordering" a b
instance (Order Float) : b a -> intrinsic "float-ordering" a b
instance (Order Double) : b a -> intrinsic "double-ordering" a b

[help "Returns `True` if the left side is less than the right side."]
[help-group "Logic"]
[operator Comparison-Precedence]
< : syntax {
  'a < 'b -> when (Order 'b 'a) {
    Ordering Less -> True
    Ordering Equal -> False
    Ordering Greater -> False
  }
  'a < -> {
    a : 'a
    b -> a < b
  }
  < 'b -> {
    b : 'b
    a -> a < b
  }
  < -> b a -> a < b
}

[help "Returns `True` if the left side is greater than the right side."]
[help-group "Logic"]
[operator Comparison-Precedence]
> : syntax {
  'a > 'b -> when (Order 'b 'a) {
    Ordering Less -> False
    Ordering Equal -> False
    Ordering Greater -> True
  }
  'a > -> {
    a : 'a
    b -> a > b
  }
  > 'b -> {
    b : 'b
    a -> a > b
  }
  > -> b a -> a > b
}

[help "Returns `True` if the left side is less than or equal to the right side."]
[help-group "Logic"]
[operator Comparison-Precedence]
<= : syntax {
  'a <= 'b -> when (Order 'b 'a) {
    Ordering Less -> True
    Ordering Equal -> True
    Ordering Greater -> False
  }
  'a <= -> {
    a : 'a
    b -> a <= b
  }
  <= 'b -> {
    b : 'b
    a -> a <= b
  }
  <= -> b a -> a <= b
}

[help "Returns `True` if the left side is greater than or equal to the right side."]
[help-group "Logic"]
[operator Comparison-Precedence]
>= : syntax {
  'a >= 'b -> when (Order 'b 'a) {
    Ordering Less -> False
    Ordering Equal -> True
    Ordering Greater -> True
  }
  'a >= -> {
    a : 'a
    b -> a >= b
  }
  >= 'b -> {
    b : 'b
    a -> a >= b
  }
  >= -> b a -> a >= b
}

[help "Implement this trait to enable equality testing between two values of your type."]
[help-group "Logic"]
Equal : A => trait (A -> A -> Boolean)

[help "Returns `True` if both sides are equal."]
[help-group "Logic"]
[operator Comparison-Precedence]
= : syntax {
  'a = 'b -> Equal 'b 'a
  'a = -> {
    a : 'a
    b -> a = b
  }
  = 'b -> {
    b : 'b
    a -> a = b
  }
  = -> Equal
}

[help "Returns `True` if the left side is not equal to the right side."]
[help-group "Logic"]
[operator Comparison-Precedence]
/= : syntax {
  'a /= 'b -> not ('a = 'b)
  'a /= -> {
    a : 'a
    b -> a /= b
  }
  /= 'b -> {
    b : 'b
    a -> a /= b
  }
  /= -> b a -> not (Equal b a)
}

instance (Equal Text) : b a -> intrinsic "text-equality" a b
instance (Equal Number) : b a -> intrinsic "number-equality" a b
instance (Equal Integer) : b a -> intrinsic "integer-equality" a b
instance (Equal Natural) : b a -> intrinsic "natural-equality" a b
instance (Equal Byte) : b a -> intrinsic "byte-equality" a b
instance (Equal Signed) : b a -> intrinsic "signed-equality" a b
instance (Equal Unsigned) : b a -> intrinsic "unsigned-equality" a b
instance (Equal Float) : b a -> intrinsic "float-equality" a b
instance (Equal Double) : b a -> intrinsic "double-equality" a b
instance (Equal ()) : () () -> True
instance (Equal Boolean) : b a -> if a b (not b)

[help "Returns the larger of the two inputs."]
[help-group "Logic"]
max :: A where (Order A) => A -> A -> A
max : a b -> if (a >= b) a b

[help "Returns the smaller of the two inputs."]
[help-group "Logic"]
min :: A where (Order A) => A -> A -> A
min : a b -> if (a <= b) a b
