[[no-std]]

use "util"
use "fp"
use "mutable"
use "list"
use "logic"
use "loop"

[help "A container for an iterable value that produces the `next` value on demand."]
[help-group "Collections"]
[help-playground "https://wipple.dev/std/examples/iterate.txt"]
Iterator : Element => type { next :: () -> Maybe Element }

[help "Create an iterator from a function."]
[help-group "Collections"]
[help-playground "https://wipple.dev/std/examples/iterate.txt"]
iterator :: Element => (() -> Maybe Element) -> Iterator Element
iterator : next -> Iterator { next }

[help "Retrieve the next item in an iterator."]
[help-group "Collections"]
[help-playground "https://wipple.dev/std/examples/iterate.txt"]
next :: Element => Iterator Element -> Maybe Element
next : { next } -> next ()

[help "Implement this trait to enable traversing your collection type."]
[help-group "Collections"]
[help-playground "https://wipple.dev/std/examples/iterate.txt"]
Iterate : Container (infer Element) => trait (Container -> Iterator Element)

Element => instance (Iterate (Iterator Element) Element) : it

[help "Transform each item in an iterator, producing a new iterator."]
[help-group "Collections"]
transform :: Container (infer Element) Result where (Iterate Container Element) => (Element -> Result) -> Container -> Iterator Result
transform : f container -> {
  base : Iterate container

  iterator (() -> when (next base) {
    Some x -> Some (f x)
    None -> None
  })
}

[help "Keep only the items in an iterator that satisfy the provided condition."]
[help-group "Collections"]
filter :: Container (infer Element) where (Iterate Container Element) => (Element -> Boolean) -> Container -> Iterator Element
filter : include? container -> {
  base : Iterate container

  iterator (() -> loop {
    when (next base) {
      Some x -> if (include? x) (Break (Some x)) Continue
      None -> Break None
    }
  })
}

[help "Reduce an iterator down to a single item."]
[help-group "Collections"]
reduce :: Container Element Result where (Iterate Container Element) => Result -> (Element -> Result -> Result) -> Container -> Result
reduce : result f container -> {
  reduce-helper :: Element Result => Result -> (Element -> Result -> Result) -> Iterator Element -> Result
  reduce-helper : result f iterator -> when (next iterator) {
    Some next -> reduce-helper (f next result) f iterator
    None -> result
  }

  reduce-helper result f (Iterate container)
}

[help "Find the sum of all the numbers in an iterator."]
[help-group "Collections"]
sum :: Container N where (Iterate Container N) (Numeric N) (Add N N N) => Container -> N
sum : reduce (zero of Numeric) Add

[help "Implement this trait to enable reducing an iterator into your collection type."]
[help-group "Collections"]
[help-playground "https://wipple.dev/std/examples/collect.txt"]
Collect : (infer Element) Container => trait (Iterator Element -> Container)

[help "Collect an iterator into a single value, like a `List`."]
[help-group "Collections"]
[help-playground "https://wipple.dev/std/examples/collect.txt"]
collect :: Input (infer Element) Output where (Collect Element Output) (Iterate Input Element) => Input -> Output -- FIXME: bound order shouldn't matter, but putting `Iterate` first breaks type inference
collect : input -> Collect (Iterate input)

Element => instance (Collect Element (List Element)) : iterator -> {
  list : mutable (list)
  loop {
    when (next iterator) {
      Some x -> {
        list . append! x
        Continue
      }
      None -> Break ()
    }
  }

  get list
}

Element => instance (Iterate (List Element) Element) : list -> {
  index : mutable 0

  iterator (() -> when (list . nth (get index)) {
    Ok element -> {
      increment! index
      Some element
    }
    Error _ -> None
  })
}

instance (Collect () ()) : iterator -> {
  loop {
    when (next iterator) {
      Some () -> Continue
      None -> Break ()
    }
  }
}

[help "Perform an action for each item in an iterator."]
[help-group "Collections"]
[help-playground "https://wipple.dev/std/examples/each.txt"]
each :: Container (infer Element) where (Iterate Container Element) => (Element -> ()) -> Container -> ()
each : f container -> container . transform f . collect

[help "Split an iterator into groups of consecutive items satisfying a condition."]
[help-group "Collections"]
split-by :: Collection (infer Element) where (Iterate Collection Element) => (Element -> Boolean) -> Collection -> Iterator (List Element)
split-by : separator? -> collection -> {
  base : Iterate collection
  group : mutable (Some (list))

  iterator (() -> loop {
    when (next base) {
      Some x -> {
        if (separator? x) { Break (take! group) } {
          group . set! (Some (when (get group) {
            Some inner -> inner . append x
            None -> list x
          }))

          Continue
        }
      }
      None -> Break (take! group)
    }
  })
}

[help "Split an iterator into groups of consecutive items equal to a value."]
[help-group "Collections"]
split :: Collection (infer Element) where (Iterate Collection Element) (Equal Element) => Element -> Collection -> Iterator (List Element)
split : separator -> split-by (x -> x = separator)

count :: Collection (infer Element) where (Iterate Collection Element) => Collection -> Natural
count : collection -> {
  iterator : Iterate collection

  count : mutable 0
  loop {
    when (next iterator :: Maybe Element) {
      Some _ -> {
        increment! count
        Continue
      }
      None -> Break ()
    }
  }

  get count
}
