//! Coordinates the compiler passes.

mod convert;

use itertools::Itertools;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

pub use wipple_codegen as codegen;
pub use wipple_lower as lower;
pub use wipple_parser as parser;
pub use wipple_query as query;
pub use wipple_syntax as syntax;
pub use wipple_typecheck as typecheck;
pub use wipple_util as util;

/// The default recursion limit.
// TODO: Make this configurable
pub const DEFAULT_RECURSION_LIMIT: u32 = 64;

/// The driver.
#[non_exhaustive]
#[derive(Debug)]
pub struct Driver {
    /// The recursion limit.
    pub recursion_limit: u32,

    interface: Interface,
    library: Library,
}

impl Driver {
    /// Create a new driver.
    pub fn new() -> Self {
        Driver {
            recursion_limit: DEFAULT_RECURSION_LIMIT,
            interface: Default::default(),
            library: Default::default(),
        }
    }
}

/// The information contained within items produced by the compiler.
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Info {
    /// Information produced by the parser.
    pub parser_info: parser::syntax::Info,
}

impl From<parser::syntax::Info> for Info {
    fn from(parser_info: parser::syntax::Info) -> Self {
        Info { parser_info }
    }
}

/// Represents a number.
pub type Number = String; // TODO: Use rust_decimal

/// A file provided to [`Driver::compile`].
#[derive(Debug, Clone)]
pub struct File {
    /// The file's path.
    pub path: String,

    /// The file's contents.
    pub code: String,
}

/// An interface generated by the compiler.
#[non_exhaustive]
#[derive(Debug, Default)]
pub struct Interface {
    /// The type declarations in the program.
    pub type_declarations:
        HashMap<lower::Path, util::WithInfo<Info, typecheck::TypeDeclaration<Driver>>>,

    /// The trait declarations in the program.
    pub trait_declarations:
        HashMap<lower::Path, util::WithInfo<Info, typecheck::TraitDeclaration<Driver>>>,

    /// The type parameters in the program.
    pub type_parameter_declarations:
        HashMap<lower::Path, util::WithInfo<Info, typecheck::TypeParameterDeclaration<Driver>>>,

    /// The language declarations in the program.
    pub language_declarations: HashMap<String, lower::Path>,

    /// The constant declarations in the program.
    pub constant_declarations:
        HashMap<lower::Path, util::WithInfo<Info, typecheck::ConstantDeclaration<Driver>>>,

    /// The instance declarations in the program.
    pub instance_declarations:
        HashMap<lower::Path, util::WithInfo<Info, typecheck::InstanceDeclaration<Driver>>>,
}

/// A library generated by the compiler.
// TODO: These should use the IR instead
#[non_exhaustive]
#[derive(Debug, Default)]
pub struct Library {
    /// The implementations of constants and instances.
    pub items: HashMap<lower::Path, util::WithInfo<Info, typecheck::TypedExpression<Driver>>>,

    /// Any code to be run when the program starts.
    pub code: Vec<util::WithInfo<Info, typecheck::TypedExpression<Driver>>>,
}

/// The result of [`Driver::compile`].
#[non_exhaustive]
#[derive(Debug)]
pub struct Result {
    /// The generated interface.
    pub interface: Interface,

    /// The generated library.
    pub library: Library,

    /// Any errors ocurring during compilation.
    pub errors: Vec<util::WithInfo<Info, Error>>,
}

/// Errors produced by the compiler.
#[allow(missing_docs)]
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Error {
    Read(parser::reader::Error),
    Parse(parser::syntax::Error),
    Syntax(syntax::Error),
    Lower(lower::Error),
    Typecheck(typecheck::Error<Driver>),
}

impl Driver {
    /// Compile a set of source files into a [`Library`] and [`Interface`].
    pub fn compile(
        mut self,
        files: impl IntoIterator<Item = File>,
        dependencies: impl IntoIterator<Item = Interface>,
    ) -> Result {
        let mut errors = Vec::new();

        let files = files.into_iter().map(|file| {
            let options = parser::reader::ReadOptions {
                strip_comments: true,
            };

            let tokenize_result = parser::reader::tokenize(&file.code);
            errors.extend(
                tokenize_result
                    .errors
                    .into_iter()
                    .map(|error| util::WithInfo {
                        info: Info {
                            parser_info: parser::syntax::Info {
                                path: file.path.clone(),
                                span: error.span.clone(),
                            },
                        },
                        item: Error::Read(error),
                    }),
            );

            let read_result = wipple_parser::reader::read(tokenize_result.tokens, options);
            errors.extend(read_result.errors.into_iter().map(|error| util::WithInfo {
                info: Info {
                    parser_info: parser::syntax::Info {
                        path: file.path.clone(),
                        span: error.span.clone(),
                    },
                },
                item: Error::Read(error),
            }));

            let syntax_driver = SyntaxDriver {
                file_path: file.path.clone(),
            };

            let syntax_result = wipple_parser::syntax::parse(&syntax_driver, read_result.top_level);
            errors.extend(
                syntax_result
                    .errors
                    .into_iter()
                    .map(|error| util::WithInfo {
                        info: Info {
                            parser_info: parser::syntax::Info {
                                path: file.path.clone(),
                                span: error.span.clone(),
                            },
                        },
                        item: Error::Parse(error),
                    }),
            );

            let parse_result = wipple_syntax::parse(&syntax_driver, syntax_result.top_level);
            errors.extend(
                parse_result
                    .errors
                    .into_iter()
                    .map(|error| error.map(Error::Syntax).map_info(Info::from)),
            );

            convert::lower::convert(parse_result.top_level)
        });

        let lower_result = wipple_lower::resolve(
            &self,
            files,
            dependencies
                .into_iter()
                .map(|interface: Interface| lower::Interface {
                    type_declarations: interface
                        .type_declarations
                        .into_iter()
                        .map(|(path, item)| {
                            (path, convert::interface::convert_type_declaration(item))
                        })
                        .collect(),
                    trait_declarations: interface
                        .trait_declarations
                        .into_iter()
                        .map(|(path, item)| {
                            (path, convert::interface::convert_trait_declaration(item))
                        })
                        .collect(),
                    type_parameter_declarations: interface
                        .type_parameter_declarations
                        .into_iter()
                        .map(|(path, item)| {
                            (
                                path,
                                convert::interface::convert_type_parameter_declaration(item),
                            )
                        })
                        .collect(),
                    language_declarations: interface.language_declarations,
                    constant_declarations: interface
                        .constant_declarations
                        .into_iter()
                        .map(|(path, item)| {
                            (path, convert::interface::convert_constant_declaration(item))
                        })
                        .collect(),
                    instance_declarations: interface
                        .instance_declarations
                        .into_iter()
                        .map(|(path, item)| {
                            (path, convert::interface::convert_instance_declaration(item))
                        })
                        .collect(),
                }),
        );

        errors.extend(
            lower_result
                .errors
                .into_iter()
                .map(|error| error.map(Error::Lower)),
        );

        for (path, item) in lower_result.interface.type_declarations {
            let declaration = convert::typecheck::convert_type_declaration(item);
            self.interface.type_declarations.insert(path, declaration);
        }

        for (path, item) in lower_result.interface.trait_declarations {
            let declaration = convert::typecheck::convert_trait_declaration(item);
            self.interface.trait_declarations.insert(path, declaration);
        }

        for (path, item) in lower_result.interface.type_parameter_declarations {
            let declaration = convert::typecheck::convert_type_parameter_declaration(item);
            self.interface
                .type_parameter_declarations
                .insert(path, declaration);
        }

        self.interface.language_declarations = lower_result.interface.language_declarations;

        for (path, item) in lower_result.interface.constant_declarations {
            let declaration = convert::typecheck::convert_constant_declaration(item);
            let body = lower_result.library.items.get(&path).unwrap().clone();

            let result = wipple_typecheck::resolve(
                &self,
                (
                    declaration.clone(),
                    convert::typecheck::convert_expression(body),
                ),
            );

            errors.extend(
                result
                    .errors
                    .into_iter()
                    .map(|error| error.map(Error::Typecheck)),
            );

            self.interface
                .constant_declarations
                .insert(path.clone(), declaration);

            self.library.items.insert(path, result.item);
        }

        for (path, item) in lower_result.interface.instance_declarations {
            let declaration = convert::typecheck::convert_instance_declaration(item);
            let body = lower_result.library.items.get(&path).unwrap().clone();

            let result = wipple_typecheck::resolve(
                &self,
                (
                    declaration.clone(),
                    convert::typecheck::convert_expression(body),
                ),
            );

            errors.extend(
                result
                    .errors
                    .into_iter()
                    .map(|error| error.map(Error::Typecheck)),
            );

            self.interface
                .instance_declarations
                .insert(path.clone(), declaration);

            self.library.items.insert(path, result.item);
        }

        {
            let result = wipple_typecheck::resolve(
                &self,
                wipple_util::WithInfo {
                    info: <Self as wipple_typecheck::Driver>::top_level_info(&self),
                    item: lower_result
                        .library
                        .code
                        .into_iter()
                        .map(convert::typecheck::convert_expression)
                        .collect(),
                },
            );

            errors.extend(
                result
                    .errors
                    .into_iter()
                    .map(|error| error.map(Error::Typecheck)),
            );

            self.library.code.push(result.item);
        }

        Result {
            interface: self.interface,
            library: self.library,
            errors: errors.into_iter().unique().collect(),
        }
    }
}

struct SyntaxDriver {
    file_path: String,
}

impl wipple_syntax::Driver for SyntaxDriver {
    type Info = Info;
    type Number = Number;

    fn file_path(&self) -> String {
        self.file_path.clone()
    }

    fn merge_info(left: Self::Info, right: Self::Info) -> Self::Info {
        Info {
            parser_info: parser::syntax::Info {
                path: left.parser_info.path,
                span: left.parser_info.span.start..right.parser_info.span.end,
            },
        }
    }
}

impl wipple_lower::Driver for Driver {
    type Info = Info;
    type Number = Number;
}

impl wipple_typecheck::Driver for Driver {
    type Info = Info;
    type Number = Number;
    type Path = wipple_lower::Path;

    fn recursion_limit(&self) -> u32 {
        self.recursion_limit
    }

    fn top_level_info(&self) -> Self::Info {
        wipple_parser::syntax::Info {
            path: String::from("<top level>"),
            span: 0..0,
        }
        .into()
    }

    fn path_for_language_type(&self, language_item: &'static str) -> Option<Self::Path> {
        Some(
            self.interface
                .language_declarations
                .get(language_item)?
                .clone(),
        )
    }

    fn path_for_language_trait(&self, language_item: &'static str) -> Option<Self::Path> {
        Some(
            self.interface
                .language_declarations
                .get(language_item)?
                .clone(),
        )
    }

    fn paths_are_equal(&self, left: &Self::Path, right: &Self::Path) -> bool {
        left == right
    }

    fn get_type_declaration(
        &self,
        path: &Self::Path,
    ) -> util::WithInfo<Self::Info, wipple_typecheck::TypeDeclaration<Self>> {
        self.interface
            .type_declarations
            .get(path)
            .expect("missing type declaration")
            .clone()
    }

    fn get_trait_declaration(
        &self,
        path: &Self::Path,
    ) -> util::WithInfo<Self::Info, wipple_typecheck::TraitDeclaration<Self>> {
        self.interface
            .trait_declarations
            .get(path)
            .expect("missing trait declaration")
            .clone()
    }

    fn get_type_parameter_declaration(
        &self,
        path: &Self::Path,
    ) -> util::WithInfo<Self::Info, wipple_typecheck::TypeParameterDeclaration<Self>> {
        self.interface
            .type_parameter_declarations
            .get(path)
            .expect("missing type parameter declaration")
            .clone()
    }

    fn get_constant_declaration(
        &self,
        path: &Self::Path,
    ) -> util::WithInfo<Self::Info, wipple_typecheck::ConstantDeclaration<Self>> {
        self.interface
            .constant_declarations
            .get(path)
            .expect("missing constant declaration")
            .clone()
    }

    fn get_instance_declaration(
        &self,
        path: &Self::Path,
    ) -> util::WithInfo<Self::Info, wipple_typecheck::InstanceDeclaration<Self>> {
        self.interface
            .instance_declarations
            .get(path)
            .expect("missing instance declaration")
            .clone()
    }

    fn get_instances_for_trait(&self, r#trait: &Self::Path) -> Vec<Self::Path> {
        self.interface
            .instance_declarations
            .iter()
            .filter(|(_, instance)| instance.item.instance.item.r#trait == *r#trait)
            .map(|(path, _)| path.clone())
            .collect()
    }

    fn get_enumeration_for_variant(&self, variant: &Self::Path) -> Self::Path {
        // The parent of a variant is its enumeration
        variant[0..variant.len() - 1].to_vec()
    }
}
