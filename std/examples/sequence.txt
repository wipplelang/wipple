---
id: a9Pw7IBT
type: text
locked: true
---

# How to use `As-Sequence`

The `As-Sequence` trait allows you to use the various sequence functions, like `each`, `transform`, `filter`, and `collect`, with your own container types:

---
id: zras8qnG
type: code
---

[help "A sequence that produces a value the specified number of times."]
Repeat : A => type {
  value :: A
  count :: Number
}

A => instance (As-Sequence (Repeat A) A) : { value count } -> {
  counter : mutable 0

  sequence {
    if (get counter = count) { None } {
      increment! counter
      Some value
    }
  }
}

repeater : Repeat {
  value : "Hello, world!"
  count : 5
}

repeater . each show

---
id: OI2ju7pw
type: text
locked: true
---

Inside the `As-Sequence` instance, you call `sequence` with a function that will be called each iteration until it returns `None`. Usually, you need to use internal mutation to keep track of the sequence's progress.

`As-Sequence` can also be used to build new "adapters" that transform the contents of another sequence, producing a new sequence. You can use `next` to manually retrieve the next item in the sequence if it exists:

---
id: OOx5eBMd
type: code
---

[help "Keep taking items from the sequence until it runs out of elements or the predicate is `False`."]
take-while :: Collection Element where (As-Sequence Collection Element) => (Element -> Boolean) -> Collection -> Sequence Element
take-while : keep? collection -> {
  seq : As-Sequence collection
  sequence {
    when (next seq) {
      Some element -> if (keep? element) (Some element) None
      None -> None
    }
  }
}

list 1 2 3 4 5 . take-while (<= 3) . each show
