sections:
  - id: Gv0dbzMx
    type: text
    value: |-
      # `Maybe` and `Result`

      It's time to put together all of our knowledge and learn about two fundamental types in Wipple, `Maybe` and `Result`. Almost every Wipple program uses these two types extensively!

      ## `Maybe`

      Let's say we have a program that asks you to input a number. But what happens if you _don't_ provide a number? How can we represent the _absence_ of a value in our program?

      Your first thought might be to designate a special number to represent the absence, like `0` or `-1`. But this isn't just confusing, it also invites bugs. Luckily, Wipple has a special enumeration, called `Maybe`, that's designed to handle this situation! Here is `Maybe` in its entirety:
    locked: true
  - id: nSZPzNke
    type: code
    value: |-
      Maybe : A => type {
      	Some A
      	None
      }

      use Maybe
  - id: cd1whHeN
    type: text
    value: |-
      What's that `A` after the `Some`? Well, in Wipple, enums can store values alongside the variant. This is an extremely powerful concept that makes it impossible for your program to be in an invalid state. `A` represents the type of the value to be stored alongside `Some`! You might see where this is going — `None` has no associated values and thus represents the absence of one.

      So how do we get the value out of the `Some`? We can use pattern matching!
    locked: true
  - id: sQT-kiJh
    type: code
    value: |-
      display-number :: Maybe Number -> ()
      display-number : input -> show (when input {
      	Some number -> format "the number you provided is _" number
      	None -> "you didn't provide a number"
      })

      display-number (Some 1)
      display-number None
  - id: 1kFjJKHv
    type: text
    value: If you're sure that there's a value inside a `Maybe`, then you can crash the program if `None` is found instead.
    locked: true
  - id: 1XPz17r5
    type: code
    value: |-
      no-number : None :: Maybe Number

      when no-number {
      	Some _ -> ...
      	None -> crash "uh oh"
      }
  - id: 0hz1Fw5X
    type: text
    value: 'This can be expressed more succinctly using `expect`, which will crash the program with the provided error message if `None` is found:'
    locked: true
  - id: Ei08FaY7
    type: code
    value: |-
      no-number : None :: Maybe Number

      expect "oh no" no-number -- oh no
  - id: Fe6Traj1
    type: text
    value: 'Or you can use `unwrap`, which provides a default error message:'
    locked: true
  - id: 54q45Gas
    type: code
    value: |-
      no-number : None :: Maybe Number

      unwrap no-number -- oh no
  - id: A71Q3sue
    type: text
    value: |-
      ## `Result`

      Returning `Maybe` from a function is useful if there's an error while processing the input — for example, if the user's input is `five` instead of `5`. But there's a better way to express errors in Wipple, and that's with the `Result` type!
    locked: true
  - id: ZsHEajlX
    type: code
    value: |-
      Result : Success Failure => type {
      	OK Success
      	Error Failure
      }
  - id: ePivF0Dz
    type: text
    value: |-
      Instead of `Some` and `None`, `Result` has `OK` (representing success) and `Error` (representing failure). Otherwise, you use them in the same way!

      Here's an example that "clamps" an number, ensuring it is within the provided range:
    locked: true
  - id: NzQuwdVl
    type: code
    value: |-
      Clamp-Error : type {
      	Too-Small
      	Too-Large
      }

      use Clamp-Error

      instance (Show Clamp-Error) : error -> when error {
      	Too-Small -> "too small"
      	Too-Large -> "too large"
      }

      clamp : min -> max -> n ->
      	if (n > min)
      	(if (n < max) (OK n) (Error Too-Large))
      	(Error Too-Small)

      single-digit : clamp -10 10

      show (single-digit 5)
      show (single-digit 20)
      show (unwrap (single-digit -42))
previous:
  name: Enumerations and pattern matching
  link: ?lesson=learn/enumerations-and-pattern-matching
next:
  name: Tuples
  link: ?lesson=learn/tuples
