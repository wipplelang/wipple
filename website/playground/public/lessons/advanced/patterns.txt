---
previous:
  name: Advanced functions
  link: ?lesson=advanced/functions
next:
  name: Tuples
  link: ?lesson=advanced/tuples
---

---
id: DVAyCHu1
type: text
locked: true
---

# Advanced patterns

In other programming languages, you typically use `null` or `None` to indicate the absence of a value. But what's the type of `null`? Is it `null :: A => A`?

Not quite. It would be impossible for the implementation of `null` to create an `A` value because it doesn't know what `A` is! `A` could be a `Number` (`0`?), or `Text` (`""`?), or a `Person` (`alice`?), or anything at all! In fact, the only way to produce an `A` value is to **exit the program**, returning no value at all. Let's try it!

---
id: 2Ou86tR6
type: code
---

always-one : when 1 {
    1 -> 1
    _ -> crash "not 1!"
}

show always-one

---
id: k76N7IAX
type: text
locked: true
---

Hover over `crash` and you'll see that, indeed, it returns an `A` value. Change `1` to `2` in the `when` expression, and you'll see that the `show` is never even executed.

The key problem here is that Wipple doesn't allow us to express the absence of a value because there's no meaningful way to give every type its own `null` value. Indeed, in languages like Java you have to put checks everywhere to ensure that a value is _not_ `null` before attempting to use it.

Wipple sidesteps this issue entirely by introducing a new type specifically for handling `null` values named `Maybe`. Let's learn how it works by building our own `My-Maybe` from scratch!

---
id: T1hEcKJG
type: code
---

My-Maybe : type {
    Some Number
    None
}

---
id: oP3gCCrr
type: text
locked: true
---

Inside `My-Maybe`, we've introduced two patterns: a `None` and a `Some` with a `Number` declared after it. When you introduce a type after a pattern, you're telling Wipple that that pattern can **hold a value**! Essentially, you're creating a **function** that accepts a `Number` and produces a `My-Maybe`. Hover over `Some` to confirm!

If `Some` is just a function, that means we can call it:

---
id: r3yegfme
type: code
lint: false
---

My-Maybe : type {
    Some Number
    None
}

maybe-a-number :: My-Maybe
maybe-a-number : Some 42

---
id: 6rsgCRaE
type: text
locked: true
---

By wrapping the number in a `My-Maybe`, we have **removed information** from our program — to the outside world, `maybe-a-number` could be `Some 42` or it could just as well be `None`. That means that in order to get the number back out, we need to handle **both cases**. That sounds like a job for `when`!

---
id: C1Xw9htH
type: code
---

My-Maybe : type {
    Some Number
    None
}

maybe-a-number :: My-Maybe
maybe-a-number : Some 42

when maybe-a-number {
    Some n -> show (format "The number is _" n)
    None -> show "There is no number"
}

---
id: mp0TcwFl
type: text
locked: true
---

Try changing `maybe-a-number` to `None` and watch how the output changes!

Right now, `My-Maybe` only works with numbers, but we can fix that by using a type function:

---
id: BkSoYSxt
type: code
---

My-Maybe : A => type {
    Some A
    None
}

-- Change these values and watch how the output changes!
maybe-a-number : Some 42
maybe-a-text : Some "Hello!"
maybe-a-maybe : Some (Some 1) -- yes, you can put a My-Maybe inside a My-Maybe!

when maybe-a-number {
    Some number -> show (format "maybe-a-number holds _" number)
    None -> show "maybe-a-number holds nothing"
}

when maybe-a-text {
    Some text -> show (format "maybe-a-text holds _" text)
    None -> show "maybe-a-text holds nothing"
}

when maybe-a-maybe {
    Some (Some number) -> show (format "maybe-a-maybe holds a maybe holding _" number)
    Some None -> show "maybe-a-maybe holds a maybe holding nothing"
    None -> show "maybe-a-maybe holds nothing"
}

---
id: aBz5qTJi
type: text
locked: true
---

Ideally, we just want to be able to `show` the `My-Maybe` directly. Let's implement `Show` using an `instance`!

---
id: hnBpanwu
type: code
---

My-Maybe : A => type {
    Some A
    None
}

instance (Show (My-Maybe Number)) : maybe -> when maybe {
    Some x -> format "(Some _)" x
    None -> "None"
}

instance (Show (My-Maybe Text)) : maybe -> when maybe {
    Some x -> format "(Some _)" x
    None -> "None"
}

instance (Show (My-Maybe (My-Maybe Number))) : maybe -> when maybe {
    Some (Some x) -> format "(Some (Some _))" x
    Some None -> "(Some None)"
    None -> "None"
}

maybe-a-number : Some 42
maybe-a-text : Some "Hello!"
maybe-a-maybe : Some (Some 1)

show maybe-a-number
show maybe-a-text
show maybe-a-maybe

---
id: OzeHAA-P
type: text
locked: true
---

Hmm, all those `instance`s seem quite similar. Maybe we can use a type function to make a single `instance` work with all `Maybe`s?

---
id: h0ms9Dph
type: code
---

My-Maybe : A => type {
    Some A
    None
}

A => instance (Show (My-Maybe A)) : maybe -> when maybe {
    Some x -> format "(Some _)" x
    None -> "None"
}

---
id: HL1kWWtD
type: text
locked: true
---

...error! `A` doesn't necessarily implement `Show`, so we can't do this. Can you figure out how to solve the problem in the space below?

---
id: 7VcHBdTi
type: code
---



---
id: aroah8eQ
type: text
locked: true
---

Hopefully you had a go at it — what we need to do is add a **bound**!

---
id: NnXRcHzE
type: code
---

My-Maybe : A => type {
    Some A
    None
}

A where (Show A) => instance (Show (My-Maybe A)) : maybe -> when maybe {
    Some x -> format "(Some _)" x
    None -> "None"
}

show (Some 42)
show (Some "Hello!")
show (Some (Some 1))

---
id: 00e15k-R
type: text
locked: true
---

Awesome! We just wrote something extremely powerful: a piece of code that works for _any value_ of `My-Maybe`.

In your own programs, you don't need to reimplement `My-Maybe` every single time — Wipple has a built-in `Maybe` type that does the same thing! If you want to check out all of the ways `Maybe` can be used, click the `+` icon on the right-hand side of the code editor and scroll down to the Utilities section.
