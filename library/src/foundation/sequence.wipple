-- A container for a sequence that produces the next value on demand.
Sequence : element => type {next :: {Maybe element}}

-- Retrieve the next item in a sequence.
next :: (Sequence element) -> Maybe element
next : (Sequence {next : next}) -> do next

-- Create a sequence.
sequence :: {Maybe element} -> Sequence element
sequence : next -> Sequence {next : next}

-- Create a sequence that always produces the provided element.
--
-- ## Example
--
-- ```wipple
-- my-sequence : always "Hello, world!"
-- show (next my-sequence) -- Hello, world!
-- show (next my-sequence) -- Hello, world!
-- show (next my-sequence) -- Hello, world!
-- ```
always :: element -> Sequence element
always : element -> sequence {Some element}

-- Create a sequence that produces the provided element a certain number of
-- times. `element . replicate n` is equivalent to `always element . take n`.
replicate :: Number -> element -> Sequence element
replicate : n -> element -> always element . take n

-- Build a sequence from an initial item and a transform function.
build-sequence :: (Maybe element) (element -> Maybe element) -> Sequence element
build-sequence : initial transform -> do {
  next : initial

  sequence {
    when next {
      (Some current) -> do {
        set next : transform current
        Some current
      }
      None -> None
    }
  }
}

-- Convert a collection into a sequence.
As-Sequence : container (infer element) => trait (container -> Sequence element)

-- Can't make a sequence from [`container`].
--
-- You can't use [`container`] as a sequence. Try using a list instead.
[default] [error] instance (As-Sequence container element)

instance (As-Sequence (Sequence element) element) : sequence -> sequence

instance (As-Sequence (Maybe element) element) : maybe -> sequence {
  when maybe {
    (Some value) -> do {
      set maybe : None
      Some value
    }
    None -> None
  }
}

transform :: (input -> output) -> container -> Sequence output where (As-Sequence container input)
transform : f -> container -> do {
  base : As-Sequence container

  sequence {
    when (next base) {
      (Some value) -> Some (f value)
      None -> None
    }
  }
}

-- Keep only the items in the sequence that satisfy the provided condition.
filter :: (element -> Boolean) -> container -> Sequence element where (As-Sequence container element)
filter : include? -> container -> do {
  base : As-Sequence container

  sequence {
    repeat with-control-flow {
      when (next base) {
        (Some value) -> if (include? value) {Stop (Some value)} {Continue ()}
        None -> Stop None
      }
    }
  }
}

-- Transform each item in a sequence, keeping only the items that aren't `None`.
filter-by :: (element -> Maybe result) -> container -> Sequence result where (As-Sequence container element)
filter-by : transform -> container -> do {
  base : As-Sequence container

  sequence {
    repeat with-control-flow {
      when (next base) {
        (Some value) -> when (transform value) {
          (Some value) -> Stop (Some value)
          None -> Continue ()
        }
        None -> Stop None
      }
    }
  }
}

-- Flatten a sequence of sequences.
flatten :: outer -> Sequence element where (As-Sequence outer inner) (As-Sequence inner element)
flatten : outer -> do {
  outer : As-Sequence outer

  when (next outer) {
    (Some inner) -> do {
      inner : As-Sequence inner

      sequence {
        repeat with-control-flow {
          when (next inner) {
            (Some value) -> Stop (Some value)
            None -> when (next outer) {
              (Some next-inner) -> do {
                set inner : As-Sequence next-inner
                Continue ()
              }
              None -> Stop None
            }
          }
        }
      }
    }
    None -> sequence {None}
  }
}

-- Find the first item in a sequence that can be transformed into a `Some` value.
find-by :: (element -> Maybe result) -> collection -> Maybe result where (As-Sequence collection element)
find-by : f -> collection -> do {
  base : As-Sequence collection

  repeat with-control-flow {
    when (next base) {
      (Some element) -> when (f element) {
        (Some result) -> Stop (Some result)
        None -> Continue ()
      }
      None -> Stop None
    }
  }
}

-- Reduce a sequence down to a single item.
reduce :: result (element -> result -> result) -> container -> result where (As-Sequence container element)
reduce : result f -> container -> As-Sequence container . reduce-helper result f

reduce-helper :: result (element -> result -> result) -> (Sequence element) -> result
reduce-helper : result f -> sequence -> when (next sequence) {
  (Some next) -> (reduce-helper (result . f next) f) sequence
  None -> result
}

-- Find the sum of all the numbers in a sequence.
sum :: container -> n where (As-Sequence container n) (Initial n) (Add n n n)
sum : reduce Initial (next -> result -> result + next)

From-Sequence : element container => trait ((Sequence element) -> container)

-- Can't create [`container`] from [`element`] items.
--
-- You can't use `collect` to create [`container`] from these items.
[default] [error] instance (From-Sequence element container)

-- Collect a sequence into a single container, like a list.
collect :: input -> output where (As-Sequence input element) (From-Sequence element output) (output :: List element)
collect : collection -> From-Sequence (As-Sequence collection)

instance (From-Sequence element (List element)) : sequence -> do {
  list : (,)

  repeat with-control-flow {
    when (next sequence) {
      (Some value) -> do {
        set list : list . append value
        Continue ()
      }
      None -> Stop ()
    }
  }

  list
}

instance (As-Sequence (List element) element) : list -> do {
  index : 0

  sequence {
    when (list . nth index) {
      (Some element) -> do {
        set index : index + 1
        Some element
      }
      None -> None
    }
  }
}

instance (From-Sequence () ()) : sequence -> repeat with-control-flow {
  when (next sequence) {
    (Some ()) -> Continue ()
    None -> Stop ()
  }
}

-- Perform an action for each item in a sequence.
each :: (element -> ()) -> container -> () where (As-Sequence container element)
each : action -> container -> container . transform action . collect

-- Split a sequence into groups of consecutive items satisfying a condition.
split-by :: (element -> Boolean) -> collection -> Sequence (List element) where (As-Sequence collection element)
split-by : separator -> collection -> do {
  base : As-Sequence collection
  group : Some (,)

  sequence {
    repeat with-control-flow {
      when (next base) {
        (Some x) -> do {
          if (separator x) {
            result : group
            set group : None
            Stop result
          } {
            inner : when group {
              (Some inner) -> inner
              None -> (,)
            }

            set group : Some (inner . append x)

            Continue ()
          }
        }
        None -> do {
          result : group
          set group : None
          Stop result
        }
      }
    }
  }
}

-- Split a sequence into groups of consecutive items equal to a value.
split :: element -> collection -> Sequence (List element) where (As-Sequence collection element) (Equal element)
split : separator -> split-by (item -> item = separator)

-- Count the number of items in a sequence.
count :: collection -> Number where (As-Sequence collection element)
count : collection -> do {
  base : As-Sequence collection

  count : 0
  repeat with-control-flow {
    when (next base) {
      (Some _) -> do {
        set count : count + 1
        Continue ()
      }
      None -> Stop count
    }
  }
}

-- Collect two sequences into a single value.
join :: a b -> c where (As-Sequence a element) (As-Sequence b element) (From-Sequence element c) (c :: a)
join : a b -> collect (flatten ((,) . append (As-Sequence a) . append (As-Sequence b)))

-- Take up to a fixed number of values from a sequence.
take :: Number -> collection -> Sequence element where (As-Sequence collection element)
take : count -> collection -> do {
  base : As-Sequence collection

  counter : 0
  sequence {
    if (counter >= count) {
      None
    } {
      set counter : counter + 1
      next base
    }
  }
}

-- Find the first item in a sequence that satisfies a condition.
find :: (element -> Boolean) -> collection -> Maybe element where (As-Sequence collection element)
find : found? -> collection -> do {
  base : As-Sequence collection

  repeat with-control-flow {
    when (next base) {
      (Some element) -> if (found? element) {Stop (Some element)} {Continue ()}
      None -> Stop None
    }
  }
}

-- Find the position of the first item in a sequence that satisfies a condition.
find-position :: (element -> Boolean) -> collection -> Maybe Number where (As-Sequence collection element)
find-position : found? -> collection -> do {
  base : As-Sequence collection
  counter : 0

  repeat with-control-flow {
    when (next base) {
      (Some element) -> if (found? element) {
        Stop (Some counter)
      } {
        set counter : counter + 1
        Continue ()
      }
      None -> Stop None
    }
  }
}

-- Returns `True` if the condition is `True` for all items in the sequence, or if the sequence is empty.
all? :: (element -> Boolean) -> collection -> Boolean where (As-Sequence collection element)
all? : condition? -> collection -> As-Sequence collection . all-helper condition?

all-helper :: (element -> Boolean) -> (Sequence element) -> Boolean
all-helper : condition? -> sequence -> when (next sequence) {
  (Some element) -> condition? element and (all-helper condition?) sequence
  None -> True
}

-- Returns `True` if the condition is `True` for any item in the sequence, or `False` if the sequence is empty.
any? :: (element -> Boolean) -> collection -> Boolean where (As-Sequence collection element)
any? : condition? -> collection -> As-Sequence collection . any-helper condition?

any-helper :: (element -> Boolean) -> (Sequence element) -> Boolean
any-helper : condition? -> sequence -> when (next sequence) {
  (Some element) -> condition? element or (any-helper condition?) sequence
  None -> False
}

-- Create a sequence that takes values from two sequences at a time until either sequence runs out.
zip :: left right -> Sequence (left-element; right-element) where (As-Sequence left left-element) (As-Sequence right right-element)
zip : left right -> do {
  left : As-Sequence left
  right : As-Sequence right

  sequence {
    when (next left; next right) {
      (Some a; Some b) -> Some (a; b)
      _ -> None
    }
  }
}

-- Create a sequence that maintains a counter indicating the number of elements
-- produced. For example, `enumerate ("a", "b", "c")` produces `(0; "a")`,
-- `(1; "b")`, and `(2; "c")`.
enumerate :: collection -> Sequence (Number; element) where (As-Sequence collection element)
enumerate : collection -> zip (0 to nan by 1) collection

Extend : container (infer element) => trait ((Sequence element) -> container -> container)
instance (Extend (List element) element) : sequence -> list -> sequence . reduce list append

-- Append the contents of a sequence to a collection.
extend :: from -> container -> container where (As-Sequence from element) (Extend container element)
extend : collection -> Extend (As-Sequence collection)

instance (Extend (left; right) (left-element; right-element)) where (Extend left left-element) (Extend right right-element) : sequence -> (left; right) -> do {
  repeat with-control-flow {
    when (next sequence) {
      (Some (a; b)) -> do {
        set left : left . extend (Some a)
        set right : right . extend (Some b)
        Continue ()
      }
      None -> Stop ()
    }
  }

  left; right
}

-- Split a sequence that produces two values at a time into two separate collections.
unzip :: collection -> (left; right) where (Initial left) (Initial right) (As-Sequence collection (left-element; right-element)) (Extend left left-element) (Extend right right-element)
unzip : collection -> (Initial; Initial) . extend (As-Sequence collection)

Container : collection (infer element) => trait (element -> collection -> Boolean)

-- Returns `True` if the collection contains the element.
contains? :: element -> collection -> Boolean where (Container collection element)
contains? : Container

instance (Container (List element) element) where (Equal element) : target -> list -> do {
  base : As-Sequence list

  repeat with-control-flow {
    when (next base) {
      (Some element) -> if (element = target) {Stop True} {Continue ()}
      None -> Stop False
    }
  }
}

instance (Add String String String) : a b -> "__" a b

instance (As-Sequence String String) : string ->
  As-Sequence (intrinsic "string-characters" string :: List String)

instance (From-Sequence String String) : reduce "" (right -> left -> left + right)
