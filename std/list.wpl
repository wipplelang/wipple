[[no-implicit-use]]

use "util"
use "fp"
use "mutable"

Build-Collection : Collection (infer Element) => trait (Element -> Mutable Collection -> ())

[private]
initial-collection :: Element (Collection : List Element) where (Default Collection) => Collection
initial-collection : Default

-- By swapping the order of the inputs, we typecheck the list before
-- typechecking the elements, so the error message is on the elements that don't
-- belong rather than on the resultant list.
[private]
[diagnostic "collection-elements"]
build-collection! :: Collection (infer Element) where (Build-Collection Collection Element) => Mutable Collection -> Element -> ()
build-collection! : c e -> c . Build-Collection e

[help "Create a collection with the specified elements. Defaults to `List` if no other type is specified."]
[help-group "Collections"]
[operator Variadic-Precedence]
, : syntax {
  , ...x -> {
    collection : mutable initial-collection
    ...{ (build-collection! collection 'x) }
    get collection
  }
}

instance (Default (List _)) : semantics "pure" (intrinsic "make-empty-list")
Element => instance (Build-Collection (List Element) Element) : append!

[help "Retrieve the first item inside a `List`, if it exists."]
[help-group "Collections"]
first :: A => List A -> Maybe A
first : l -> semantics "pure" (intrinsic "list-first" l)

[help "Retrieve the last item inside a `List`, if it exists."]
[help-group "Collections"]
last :: A => List A -> Maybe A
last : l -> semantics "pure" (intrinsic "list-last" l)

[help "Retrieve all but the last item inside a `List`."]
[help-group "Collections"]
initial :: A => List A -> Maybe (List A)
initial : l -> semantics "pure" (intrinsic "list-initial" l)

[help "Retrieve all but the first item inside a `List`."]
[help-group "Collections"]
tail :: A => List A -> Maybe (List A)
tail : l -> semantics "pure" (intrinsic "list-tail" l)

[help "Retrieve the value in a `List` at a particular index, if it exists."]
[help-group "Collections"]
nth :: A => Natural -> List A -> Maybe A
nth : index l -> semantics "pure" (intrinsic "list-nth" l index)

[help "Add a new item to the end of a `List`."]
[help-group "Collections"]
[diagnostic "collection-elements"]
append :: A => A -> List A -> List A
append : new l -> semantics "pure" (intrinsic "list-append" l new)

[help "Add a new item to the end of a `Mutable List`."]
[help-group "Collections"]
append! :: A => A -> Mutable (List A) -> ()
append! : new l -> l . set! (l . get . append new)

[help "Insert a new item at a particular index inside a `List`."]
[help-group "Collections"]
insert-at :: A => Natural -> A -> List A -> Maybe (List A)
insert-at : index new l -> semantics "pure" (intrinsic "list-insert-at" l index new)

[help "Insert a new item at a particular index inside a `Mutable List`."]
[help-group "Collections"]
insert-at! :: A => Natural -> A -> Mutable (List A) -> Boolean
insert-at! : index new l -> when (l . get . insert-at index new) {
  Some new-list -> {
    l . set! new-list
    True
  }
  None -> False
}

[help "Remove the item at a particular index inside a `List`."]
[help-group "Collections"]
remove-at :: A => Natural -> List A -> Maybe (List A)
remove-at : index l -> semantics "pure" (intrinsic "list-remove-at" l index)

[help "Remove the item at a particular index inside a `Mutable List`."]
[help-group "Collections"]
remove-at! :: Natural -> Mutable (List _) -> Boolean
remove-at! : index l -> when (l . get . remove-at index) {
  Some new-list -> {
    l . set! new-list
    True
  }
  None -> False
}
