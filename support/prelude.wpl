-- Functional programming --

[help "Returns its input unmodified."]
it :: A => A -> A
it : x -> x

[help "Ignores its second input."]
just :: A B => A -> B -> A
just : x -> _ -> x

. : dot operator (x f ~> f x)

-- Logic --

[language "boolean"]
[help "Represents either `True` or `False`."]
Boolean : type {
	False
	True
}

use Boolean

if : bool then else ~> when bool {
	False -> else
	True -> then
}

if? : bool then ~> if bool then ()

[help "Returns `False` if provided `True`, and vice versa."]
not :: Boolean -> Boolean
not : bool -> if bool False True

And : Left Right Output => trait (Left -> (() -> Right) -> Output)
and : conjunction operator (a b ~> And a (() -> b))
instance And Boolean Boolean Boolean : a? -> b? -> if a? (b? ()) False

Or : Left Right Output => trait (Left -> (() -> Right) -> Output)
-- `or` operator is defined in the compiler to accommodate `or` patterns
instance Or Boolean Boolean Boolean : a? -> b? -> if a? True (b? ())

[help "The result of a comparison between two values."]
Ordering : type {
	Less
	Equal
	Greater
}

[help "Implement this trait to enable comparisons between two values of your type."]
Order : A => trait (A -> A -> Ordering)

instance Order Number : a -> b -> external "builtin" "number-ordering" a b

< : comparison operator (a b ~> when (Order a b) {
	Ordering Less -> True
	Ordering Equal -> False
	Ordering Greater -> False
})

> : comparison operator (a b ~> when (Order a b) {
	Ordering Less -> False
	Ordering Equal -> False
	Ordering Greater -> True
})

<= : comparison operator (a b ~> when (Order a b) {
	Ordering Less -> True
	Ordering Equal -> True
	Ordering Greater -> False
})

>= : comparison operator (a b ~> when (Order a b) {
	Ordering Less -> False
	Ordering Equal -> True
	Ordering Greater -> True
})

[help "Implement this trait to enable equality testing between two values of your type."]
Equal : A => trait (A -> A -> Boolean)
= : comparison operator (a b ~> Equal a b)
/= : comparison operator (a b ~> not (a = b))

instance Equal Number : a -> b -> when (Order a b) {
	Ordering Less -> False
	Ordering Equal -> True
	Ordering Greater -> False
}

instance Equal Text : a -> b -> external "builtin" "text-equality" a b
instance Equal () : () -> () -> True
instance Equal Boolean : a? -> b? -> a? and b? or not a? and not b?

-- Output --

[help "Display text on the screen. `print` writes directly to the standard output with no trailing newline."]
print :: Text -> ()
print : text -> external "builtin" "print" text

[help "Implement this trait to enable `show`ing values of your type."]
Show : A => trait (A -> Text)
instance Show Text : it
instance Show Number : n -> external "builtin" "number-to-text" n
instance Show Boolean : x? -> if x? "True" "False"

[help "Display a value on the screen."]
show :: A where (Show A) => A -> ()
show : x -> print (format "_\n" x)

-- Utilities --

[help "Crash the program with the provided message."]
crash :: Text -> !
crash : message -> external "builtin" "crash" message

[help "Indicates unfinished code. Crashes the program upon evaluation."]
... :: !
... : crash "not yet implemented"

[help "Represents the default or initial value of a type."]
Default : A => trait A
instance Default Number : 0
instance Default Text : ""
instance Default Boolean : False

[help "Represents the presence or absence of a value."]
Maybe : Value => type {
	None
	Some Value
}

use Maybe

Value where (Show Value) => instance Show (Maybe Value) : x? -> when x? {
	Some x -> format "Some _" (Show x)
	None -> "None"
}

[help "Represents the success or failure of an operation."]
Result : Success Failure => type {
	OK Success
	Error Failure
}

use Result

[help "Implement this trait to enable usage of your type in error handling."]
Try : Value Success Failure => trait (Value -> Result Success Failure)

[help "Represents the failure to find a value inside a `Maybe`."]
None-Error : type

instance Show None-Error : just "found `None`"

A => instance Try (Maybe A) A None-Error : x? -> when x? {
	Some x -> OK x
	None -> Error None-Error
}

Success Failure => instance Try (Result Success Failure) Success Failure : it

try : x? ~> when (Try x?) {
	OK x -> x
	Error e -> return (Error e)
}

Success Failure where (Show Success) (Show Failure) =>
	instance Show (Result Success Failure) :
		x? -> when x? {
		OK x -> format "OK _" (Show x)
		Error e -> format "Error _" (Show e)
	}

-- TODO: Use higher-kinded types
Expect : Container Value => trait (Text -> Container -> Value)

Value => instance Expect (Maybe Value) Value : message -> x? -> when x? {
	Some x -> x
	None -> crash message
}

Success Failure where (Show Failure) =>
	instance Expect (Result Success Failure) Success :
		message -> x? -> when x? {
			OK x -> x
			Error e -> crash (format "_: _" message e)
		}

Unwrap-Message : Container => trait (Container -> Text)

Value => instance Unwrap-Message (Maybe Value) :
	just "called `unwrap` on `None`"

Success Failure => instance Unwrap-Message (Result Success Failure) :
	just "called `unwrap` on `Error`"

-- TODO: Use higher-kinded types
[help "Produces the `Some` value contained within a `Maybe`, or crashes the program with the provided message."]
expect :: Container Value where (Expect Container Value) =>
	Text -> Container -> Value
expect : Expect

-- TODO: Use higher-kinded types
[help "Produces the `Some` value contained within a `Maybe`, or crashes the program."]
unwrap :: Container Value
	where (Expect Container Value) (Unwrap-Message Container) =>
	Container -> Value
unwrap : x? -> expect (Unwrap-Message x?) x?

-- Math --

[help "Implements the `+` operator."]
Add : Left Right Sum => trait (Left -> Right -> Sum)
+ : addition operator (a b ~> Add a b)
instance Add Number Number Number : a -> b -> external "builtin" "add" a b
instance Add Text Text Text : a -> b -> format "__" a b

[help "Implements the `-` operator."]
Subtract : Left Right Difference => trait (Left -> Right -> Difference)
- : addition operator (a b ~> Subtract a b)
instance Subtract Number Number Number : a -> b -> external "builtin" "subtract" a b

[help "Implements the `*` operator."]
Multiply : Left Right Product => trait (Left -> Right -> Product)
* : multiplication operator (a b ~> Multiply a b)
instance Multiply Number Number Number : a -> b -> external "builtin" "multiply" a b

[help "Implements the `/` operator."]
Divide : Left Right Quotient => trait (Left -> Right -> Quotient)
/ : multiplication operator (a b ~> Divide a b)
instance Divide Number Number Number : a -> b -> external "builtin" "divide" a b

[help "Implements the `^` operator."]
Power : Left Right Power => trait (Left -> Right -> Power)
^ : power operator (a b ~> Power a b)
instance Power Number Number Number : a -> b -> external "builtin" "power" a b

[help "Rounds down a number to the nearest integer."]
floor :: Number -> Number
floor : n -> external "builtin" "floor" n

[help "Rounds up a number to the nearest integer."]
ceil :: Number -> Number
ceil : n -> external "builtin" "ceil" n

[help "Calculates the square root of a number."]
sqrt :: Number -> Number
sqrt : n -> external "builtin" "sqrt" n

-- Mutability --

[help "Create a new `Mutable` value."]
mutable :: A => A -> Mutable A
mutable : x -> external "builtin" "make-mutable" x

[help "Retrieve the value inside a `Mutable`."]
get :: A => Mutable A -> A
get : m -> external "builtin" "get-mutable" m

[help "Update the value contained inside a `Mutable`."]
set! :: A => A -> Mutable A -> ()
set! : x -> m -> external "builtin" "set-mutable" m x

[help "Swap the contents of two `Mutable` values."]
swap! :: A => Mutable A -> Mutable A -> ()
swap! : a -> b -> {
	temp : get a
	a . set! b
	b . set! temp
}

[help "Add a value to a `Mutable` value."]
add! :: Left Right where (Add Left Right Left) => Right -> Mutable Left -> ()
add! : x -> m -> m . set! (get m + x)

[help "Increment a `Mutable` value."]
increment! :: A where (Add A Number A) => Mutable A -> ()
increment! : add! 1

-- Loops --

Control-Flow : A => type {
	Continue
	Break A
}

use Control-Flow

-- [private]
loop-impl :: A => (() -> Control-Flow A) -> A
loop-impl : body -> external "builtin" "loop" body

loop : body ~> loop-impl (() -> body)

forever : body ~> loop {
	body :: ()
	Continue :: Control-Flow !
}

while : condition body ~> loop {
	if condition {
		body
		Continue
	} {
		Break ()
	}
}

unless : condition body ~> while (not condition) body

-- Lists --

[help "Retrieve the first item inside a `List`, if it exists."]
first :: A => List A -> Maybe A
first : list -> external "builtin" "list-first" list

[help "Retrieve the last item inside a `List`, if it exists."]
last :: A => List A -> Maybe A
last : list -> external "builtin" "list-last" list

[help "Retrieve all but the last item inside a `List`."]
initial :: A => List A -> List A
initial : list -> external "builtin" "list-initial" list

[help "Retrieve all but the first item inside a `List`."]
tail :: A => List A -> List A
tail : list -> external "builtin" "list-tail" list

Index-Error : type

instance Show Index-Error : just "invalid index"

[help "Retrieve the value in a `List` at a particular index, if it exists."]
at :: A => Number -> List A -> Result A Index-Error
at : index -> list -> external "builtin" "list-at" list index

[help "Add a new item to the end of a `List`."]
append :: A => A -> List A -> List A
append : new -> list -> external "builtin" "list-append" list new

[help "Add a new item to the end of a `Mutable List`."]
append! :: A => A -> Mutable (List A) -> ()
append! : new -> list -> list . set! (list . get . append new)

[help "Insert a new item at a particular index inside a `List`."]
insert :: A => Number -> A -> List A -> Result (List A) Index-Error
insert : index -> new -> list -> external "builtin" "list-insert" list index new

[help "Insert a new item at a particular index inside a `Mutable List`."]
insert! :: A => Number -> A -> Mutable (List A) -> Result () Index-Error
insert! : index -> new -> list -> {
	new-list : try (list . get . insert index new)
	list . set! new-list
	OK ()
}

[help "Remove the item at a particular index inside a `List`."]
remove :: A => Number -> List A -> Result (List A) Index-Error
remove : index -> list -> external "builtin" "list-remove" list index

[help "Remove the item at a particular index inside a `Mutable List`."]
remove! :: A => Number -> Mutable (List A) -> Result () Index-Error
remove! : index -> list -> {
	new-list : try (list . get . remove index)
	list . set! new-list
	OK ()
}

-- Iterators --

[help "A container for an iterable value that produces the `next` value on demand."]
Iterator : Context Element => type {
	context :: Mutable Context
	next :: Mutable Context -> Maybe Element
}

[help "Implement this trait to enable traversing your collection type."]
Iterate : Context Container Element => trait (Container -> Iterator Context Element)

Context Element => instance Iterate Context (Iterator Context Element) Element : it

-- reduce :: Context Container Element Result where (Iterate Context Container Element) => (Element -> Result -> Result) -> Container -> Iterator Context Result
-- reduce : TODO

-- TODO: Use higher-kinded types
[help "Keep only the items that satisfy the provided condition."]
filter :: Context Container Element where (Iterate Context Container Element) => (Element -> Boolean) -> Container -> Iterator Context Element
filter : include? -> container -> {
	{ context next } : Iterate container
	Iterator {
		context : context
		next : context -> loop {
			when (next context) {
				Some x -> if (include? x) (Break (Some x)) Continue
				None -> Break None
			}
		}
	}
}

-- TODO: Use higher-kinded types
[help "Execute a function for each item in an iterator."]
each :: Context Container Element where (Iterate Context Container Element) => (Element -> ()) -> Container -> ()
each : f -> container -> {
	{ context next } : Iterate container

	loop {
		when (next context) {
			Some x -> {
				f x
				Continue
			}
			None -> Break ()
		}
	}
}

-- TODO: Use higher-kinded types
[help "Implement this trait to enable reducing an iterator into your collection type."]
Collect : Context Element Container => trait (Iterator Context Element -> Container)

-- TODO: Use higher-kinded types
[help "Collect an iterator into a single value, like a `List`."]
collect :: Context Input Element Output where (Iterate Context Input Element) (Collect Context Element Output) => Input -> Output
collect : input -> Collect (Iterate input)

Context Element => instance Collect Context Element (List Element) : { context next } -> {
	list : mutable '()
	loop {
		when (next context) {
			Some x -> {
				list . append! x
				Continue
			}
			None -> Break ()
		}
	}

	get list
}

Context Element => instance Collect Context Text Text : { context next } -> {
	text : mutable ""
	loop {
		when (next context) {
			Some x -> {
				text . add! x
				Continue
			}
			None -> Break ()
		}
	}

	get text
}

A => instance Iterate Number (List A) A : list -> Iterator {
	context : mutable 0
	next : index -> {
		when (list . at (get index)) {
			OK element -> {
				increment! index
				Some element
			}
			Error _ -> None
		}
	}
}
