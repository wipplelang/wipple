[[no-std]]

[language "boolean"]
[help "Represents either `True` or `False`."]
[help-group "Logic"]
Boolean : type {
  False
  True
}

[keyword]
if : syntax {
  if 'bool 'then 'else -> when 'bool {
    True -> 'then
    False -> 'else
  }
  if 'bool 'then -> if 'bool 'then ()
}

[help "Returns `False` if provided `True`, and vice versa."]
[help-group "Logic"]
not :: Boolean -> Boolean
not : bool -> if bool False True

And : Left Right Output => trait (Left -> (() -> Right) -> Output)

[operator Conjunction-Precedence]
and : syntax { 'a and 'b -> And 'a (() -> 'b) }

instance (And Boolean Boolean Boolean) : a? -> b? -> if a? (b? ()) False

Or : Left Right Output => trait (Left -> (() -> Right) -> Output)

[operator Disjunction-Precedence]
or : syntax { 'a or 'b -> Or 'a (() -> 'b) }

instance (Or Boolean Boolean Boolean) : a? -> b? -> if a? True (b? ())

[help "The result of a comparison between two values."]
[help-group "Logic"]
Ordering : type {
  Less
  Equal
  Greater
}

[help "Implement this trait to enable comparisons between two values of your type."]
[help-group "Logic"]
Order : A => trait (A -> A -> Ordering)

instance (Order Number) : a b -> external "runtime" "number-ordering" a b
instance (Order Integer) : a b -> external "runtime" "integer-ordering" a b
instance (Order Natural) : a b -> external "runtime" "natural-ordering" a b
instance (Order Byte) : a b -> external "runtime" "byte-ordering" a b
instance (Order Signed) : a b -> external "runtime" "signed-ordering" a b
instance (Order Unsigned) : a b -> external "runtime" "unsigned-ordering" a b
instance (Order Float) : a b -> external "runtime" "float-ordering" a b
instance (Order Double) : a b -> external "runtime" "double-ordering" a b

[operator Comparison-Precedence]
< : syntax {
  'a < 'b -> when (Order 'a 'b) {
    Ordering Less -> True
    Ordering Equal -> False
    Ordering Greater -> False
  }
}

[operator Comparison-Precedence]
> : syntax {
  'a > 'b -> when (Order 'a 'b) {
    Ordering Less -> False
    Ordering Equal -> False
    Ordering Greater -> True
  }
}

[operator Comparison-Precedence]
<= : syntax {
  'a <= 'b -> when (Order 'a 'b) {
    Ordering Less -> True
    Ordering Equal -> True
    Ordering Greater -> False
  }
}

[operator Comparison-Precedence]
>= : syntax {
  'a >= 'b -> when (Order 'a 'b) {
    Ordering Less -> False
    Ordering Equal -> True
    Ordering Greater -> True
  }
}

[help "Implement this trait to enable equality testing between two values of your type."]
[help-group "Logic"]
Equal : A => trait (A -> A -> Boolean)

[operator Comparison-Precedence]
= : syntax { 'a = 'b -> Equal 'a 'b }

[operator Comparison-Precedence]
/= : syntax { 'a /= 'b -> not ('a = 'b) }

instance (Equal Text) : a b -> external "runtime" "text-equality" a b
instance (Equal Number) : a b -> external "runtime" "number-equality" a b
instance (Equal Integer) : a b -> external "runtime" "integer-equality" a b
instance (Equal Natural) : a b -> external "runtime" "natural-equality" a b
instance (Equal Byte) : a b -> external "runtime" "byte-equality" a b
instance (Equal Signed) : a b -> external "runtime" "signed-equality" a b
instance (Equal Unsigned) : a b -> external "runtime" "unsigned-equality" a b
instance (Equal Float) : a b -> external "runtime" "float-equality" a b
instance (Equal Double) : a b -> external "runtime" "double-equality" a b
instance (Equal ()) : () -> () -> True
instance (Equal Boolean) : a b -> if a b (not b)

Numeric-Impl : N => type { zero :: N }

Numeric : N => trait (Numeric-Impl N)

instance (Numeric Number) : Numeric-Impl { zero : 0 }

instance (Numeric Integer) : Numeric-Impl { zero : 0 }

instance (Numeric Natural) : Numeric-Impl { zero : 0 }

instance (Numeric Byte) : Numeric-Impl { zero : 0 }

instance (Numeric Signed) : Numeric-Impl { zero : 0 }

instance (Numeric Unsigned) : Numeric-Impl { zero : 0 }

instance (Numeric Float) : Numeric-Impl { zero : 0 }

instance (Numeric Double) : Numeric-Impl { zero : 0 }
