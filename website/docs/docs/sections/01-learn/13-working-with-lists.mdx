## Working with lists

Lists are another useful tool in programming. Let's say you're hosting a party and want to spread the word:

```wipple
Contact : type {
	name :: Text
	busy :: Boolean
}

party-time :: Contact -> ()
party-time : { name busy } ->
	if busy
		() -- don't alert the contact if they're busy
		(show (format "Hi _, you're invited to my party!" name))
```

We could start by alerting everyone we know:

```wipple
alice : Contact {
	name : "Alice"
	busy : False
}

bob : Contact {
	name : "Bob"
	busy : True
}

charlie : Contact {
	name : "Charlie"
	busy : False
}

party-time alice
party-time bob
party-time charlie
```

But there's a problem: what if there are more contacts? We'd have to add another call to `party-time` — as many as there are contacts! Even worse, what if we don't know how many contacts there are as we're writing the program? Luckily, lists make it easy to deal with changing amounts of information.

Let's create our first list — all you have to do is put a quote (`'`) in front of a group of parenthesis:

```wipple
contacts : '(alice bob charlie)
```

Hover over `contacts` and you'll see it has the type `List Contact`. Perfect!

Now we can use the `each` function to call `party-time` for each contact in the list:

```wipple
each party-time contacts
```

Great! There's one more thing we can do to clean up this code a little bit — instead of having the `if` condition inside `party-time`, we can filter out contacts in the list that are busy. To accomplish this, we can use the `filter` function:

```wipple
party-time :: Contact -> ()
party-time : { name } -> show (format "Hi _, you're invited to my party!" name)

each party-time (filter (({ busy } :: Contact) -> not busy) contacts)
```

(Why do we need the `:: Contact` type annotation? Wipple's type system is still in development and has a few bugs affecting type inference. In the future, you won't need this annotation!)

Hmm, this code is a bit hard to read. Fear not — Wipple has another construct to make it easier to compose functions like this! Any time you see `f x`, you can replace it with `x . f`. This is where partial application shines!

```wipple
contacts
	. filter (({ busy } :: Contact) -> not busy)
	. each party-time
```

Much better!
