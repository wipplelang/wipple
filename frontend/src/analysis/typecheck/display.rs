use crate::FieldIndex;

use super::{
    Arm, Expression, ExpressionKind, Pattern, PatternKind, Program, Type, TypeAnnotation,
    TypeAnnotationKind, TypeDeclKind, TypeStructure,
};
use std::fmt;

impl fmt::Display for Program {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(
            f,
            "-- This file was generated by the Wipple compiler for debugging purposes."
        )?;
        writeln!(f)?;

        for decl in self.declarations.constants.values() {
            write!(f, "{} :: ", decl.name)?;
            decl.ty_annotation.display_with(f, self)?;
            writeln!(f)?;

            if let Some(value) = &decl.body {
                write!(f, "{} : ", decl.name)?;
                value.display_with(f, self, 0)?;
            }

            writeln!(f)?;
            writeln!(f)?;
        }

        for decl in self
            .declarations
            .instances
            .values()
            .flat_map(|instances| instances.values())
        {
            let trait_name = self
                .declarations
                .traits
                .get(&decl.trait_id)
                .map(|tr| tr.name.to_string())
                .unwrap_or_else(|| format!("<unknown trait #{}>", decl.trait_id.counter));

            write!(f, "instance ({}", trait_name)?;

            for ty in &decl.trait_param_annotations {
                write!(f, " ")?;
                ty.display_with(f, self)?;
            }

            write!(f, ")")?;

            if let Some(value) = &decl.body {
                write!(f, " : ")?;
                value.display_with(f, self, 0)?;
            }

            writeln!(f)?;
            writeln!(f)?;
        }

        if let Some(entrypoint) = &self.entrypoint {
            let (_, value) = self.items.get(entrypoint).unwrap();
            value.display_with(f, self, 0)?;
        }

        Ok(())
    }
}

impl Expression {
    fn display_with(&self, f: &mut impl fmt::Write, file: &Program, indent: usize) -> fmt::Result {
        match &self.kind {
            ExpressionKind::Error(_) => write!(f, "<error>")?,
            ExpressionKind::Marker => {
                let id = match self.ty {
                    Type::Named(id, _, _) => id,
                    _ => {
                        write!(f, "<error>")?;
                        return Ok(());
                    }
                };

                let name = match file.declarations.types.get(&id) {
                    Some(decl) => decl.name,
                    None => {
                        write!(f, "<error>")?;
                        return Ok(());
                    }
                };

                write!(f, "{}", name)?;
            }
            ExpressionKind::Constant(item) | ExpressionKind::ExpandedConstant(item) => {
                match file.items.get(item) {
                    Some((Some(id), _)) => {
                        if let Some(tr) =
                            file.declarations
                                .instances
                                .iter()
                                .find_map(|(tr, instances)| {
                                    instances
                                        .get(id)
                                        .map_or(false, |instance| instance.item == *item)
                                        .then_some(tr)
                                })
                        {
                            let name = file
                                .declarations
                                .traits
                                .get(tr)
                                .map(|tr| tr.name.to_string())
                                .unwrap_or_else(|| format!("<unknown trait #{}>", tr.counter));

                            write!(f, "{}", name)?;
                        } else {
                            let name = file
                                .declarations
                                .constants
                                .get(id)
                                .map(|constant| constant.name.to_string())
                                .unwrap_or_else(|| format!("<unknown constant #{}>", id.counter));

                            write!(f, "{}", name)?;
                        }
                    }
                    _ => {
                        write!(f, "<error>")?;
                        return Ok(());
                    }
                };
            }
            ExpressionKind::Variable(id) => {
                let name = file
                    .declarations
                    .variables
                    .get(id)
                    .and_then(|var| var.name.as_deref().map(ToString::to_string))
                    .unwrap_or_else(|| format!("<unknown variable #{}>", id.counter));

                write!(f, "{}", name)?;
            }
            ExpressionKind::Text(value) => write!(f, "{:?}", value)?,
            ExpressionKind::Number(value) => write!(f, "{}", value)?,
            ExpressionKind::Integer(value) => write!(f, "{}", value)?,
            ExpressionKind::Natural(value) => write!(f, "{}", value)?,
            ExpressionKind::Byte(value) => write!(f, "{}", value)?,
            ExpressionKind::Signed(value) => write!(f, "{}", value)?,
            ExpressionKind::Unsigned(value) => write!(f, "{}", value)?,
            ExpressionKind::Float(value) => write!(f, "{}", value)?,
            ExpressionKind::Double(value) => write!(f, "{}", value)?,
            ExpressionKind::Block(exprs) => {
                writeln!(f, "{{")?;
                for expr in exprs {
                    write!(f, "{}", "\t".repeat(indent + 1))?;
                    expr.display_with(f, file, indent + 1)?;
                    writeln!(f)?;
                }
                write!(f, "{}}}", "\t".repeat(indent))?;
            }
            ExpressionKind::End(expr) => {
                write!(f, "(end ")?;
                expr.display_with(f, file, indent)?;
                write!(f, ")")?;
            }
            ExpressionKind::Call(func, input) => {
                write!(f, "(")?;
                func.display_with(f, file, indent)?;
                write!(f, " ")?;
                input.display_with(f, file, indent)?;
                write!(f, ")")?;
            }
            ExpressionKind::Function(pattern, value, _) => {
                let input_ty = match &self.ty {
                    Type::Function(input, _) => input,
                    _ => {
                        write!(f, "<error>")?;
                        return Ok(());
                    }
                };

                write!(f, "(")?;
                pattern.display_with(f, input_ty, file, indent)?;
                write!(f, " -> ")?;
                value.display_with(f, file, indent)?;
                write!(f, ")")?;
            }
            ExpressionKind::When(expr, arms) => {
                let input_ty = &expr.ty;

                write!(f, "(when ")?;
                expr.display_with(f, file, indent)?;
                writeln!(f, " {{")?;
                for arm in arms {
                    write!(f, "{}", "\t".repeat(indent + 1))?;
                    arm.display_with(f, input_ty, file, indent + 1)?;
                    writeln!(f)?;
                }
                write!(f, "{}}})", "\t".repeat(indent))?;
            }
            ExpressionKind::External(namespace, identifier, inputs) => {
                write!(f, "(external {:?} {:?}", namespace, identifier)?;
                for expr in inputs {
                    write!(f, " ")?;
                    expr.display_with(f, file, indent)?;
                }
                write!(f, ")")?;
            }
            ExpressionKind::Runtime(func, inputs) => {
                write!(f, "(external {:?} {:?}", "runtime", func.to_string())?;
                for expr in inputs {
                    write!(f, " ")?;
                    expr.display_with(f, file, indent)?;
                }
                write!(f, ")")?;
            }
            ExpressionKind::Initialize(pattern, value) => {
                pattern.display_with(f, &value.ty, file, indent)?;
                write!(f, " : ")?;
                value.display_with(f, file, indent)?;
            }
            ExpressionKind::Structure(fields) => {
                let id = match self.ty {
                    Type::Named(id, _, _) => id,
                    _ => {
                        write!(f, "<error>")?;
                        return Ok(());
                    }
                };

                let ty = match file.declarations.types.get(&id) {
                    Some(ty) => ty,
                    None => {
                        write!(f, "<error>")?;
                        return Ok(());
                    }
                };

                let name = ty.name;
                let field_names = match &ty.kind {
                    TypeDeclKind::Structure { field_names, .. } => field_names,
                    _ => {
                        write!(f, "<error>")?;
                        return Ok(());
                    }
                };

                writeln!(f, "({:?} {{", name)?;
                for (index, value) in fields.iter().enumerate() {
                    let name = field_names
                        .iter()
                        .find_map(|(name, i)| {
                            (*i == FieldIndex::new(index)).then_some(name.to_string())
                        })
                        .unwrap_or_else(|| format!("<unknown field #{}>", index));

                    write!(f, "{}{} : ", "\t".repeat(indent + 1), name)?;
                    value.display_with(f, file, indent + 1)?;
                    writeln!(f)?;
                }
                write!(f, "{}}})", "\t".repeat(indent))?;
            }
            ExpressionKind::Variant(index, values) => {
                let id = match self.ty {
                    Type::Named(id, _, _) => id,
                    _ => {
                        write!(f, "<error>")?;
                        return Ok(());
                    }
                };

                let ty = match file.declarations.types.get(&id) {
                    Some(ty) => ty,
                    None => {
                        write!(f, "<error>")?;
                        return Ok(());
                    }
                };

                let ty_name = ty.name;

                let variant_names = match &ty.kind {
                    TypeDeclKind::Enumeration { variant_names, .. } => variant_names,
                    _ => {
                        write!(f, "<error>")?;
                        return Ok(());
                    }
                };

                let variant_name = variant_names
                    .iter()
                    .find_map(|(name, i)| (i == index).then_some(name.to_string()))
                    .unwrap_or_else(|| format!("<unknown variant #{}>", index.into_inner()));

                write!(f, "({} {}", ty_name, variant_name)?;
                for value in values {
                    write!(f, " ")?;
                    value.display_with(f, file, indent)?;
                }
                write!(f, ")")?;
            }
            ExpressionKind::Tuple(exprs) => {
                write!(f, "(")?;
                for (index, expr) in exprs.iter().enumerate() {
                    if index != 0 {
                        write!(f, " , ")?;
                    }

                    expr.display_with(f, file, indent)?;
                }
                write!(f, ")")?;
            }
        }

        Ok(())
    }
}

impl Arm {
    fn display_with(
        &self,
        f: &mut impl fmt::Write,
        input_ty: &Type,
        file: &Program,
        indent: usize,
    ) -> fmt::Result {
        self.pattern.display_with(f, input_ty, file, indent)?;
        write!(f, " -> ")?;
        self.body.display_with(f, file, indent)?;
        Ok(())
    }
}

impl Pattern {
    fn display_with(
        &self,
        f: &mut impl fmt::Write,
        input_ty: &Type,
        file: &Program,
        indent: usize,
    ) -> fmt::Result {
        match &self.kind {
            PatternKind::Error(_) => write!(f, "<error>")?,
            PatternKind::Wildcard => write!(f, "_")?,
            PatternKind::Text(value) => write!(f, "{:?}", value)?,
            PatternKind::Number(value) => write!(f, "{}", value)?,
            PatternKind::Integer(value) => write!(f, "{}", value)?,
            PatternKind::Natural(value) => write!(f, "{}", value)?,
            PatternKind::Byte(value) => write!(f, "{}", value)?,
            PatternKind::Signed(value) => write!(f, "{}", value)?,
            PatternKind::Unsigned(value) => write!(f, "{}", value)?,
            PatternKind::Float(value) => write!(f, "{}", value)?,
            PatternKind::Double(value) => write!(f, "{}", value)?,
            PatternKind::Variable(id) => {
                let name = file
                    .declarations
                    .variables
                    .get(id)
                    .and_then(|decl| decl.name.as_deref().map(ToString::to_string))
                    .unwrap_or_else(|| format!("<unknown variable #{}>", id.counter));

                write!(f, "{}", name)?;
            }
            PatternKind::Destructure(fields) => {
                let (id, field_tys) = match input_ty {
                    Type::Named(id, _, TypeStructure::Structure(fields)) => (id, fields),
                    _ => {
                        write!(f, "<error>")?;
                        return Ok(());
                    }
                };

                let ty = match file.declarations.types.get(id) {
                    Some(ty) => ty,
                    None => {
                        write!(f, "<error>")?;
                        return Ok(());
                    }
                };

                let field_names = match &ty.kind {
                    TypeDeclKind::Structure { field_names, .. } => field_names,
                    _ => {
                        write!(f, "<error>")?;
                        return Ok(());
                    }
                };

                writeln!(f, "{{")?;
                for ((index, pattern), ty) in fields.iter().zip(field_tys) {
                    let name = field_names
                        .iter()
                        .find_map(|(name, i)| (i == index).then(|| name.to_string()))
                        .unwrap_or_else(|| format!("<unknown field #{}>", index.into_inner()));

                    write!(f, "{}{} : ", "\t".repeat(indent + 1), name)?;
                    pattern.display_with(f, ty, file, indent + 1)?;
                    writeln!(f)?;
                }
                write!(f, "{}}}", "\t".repeat(indent))?;
            }
            PatternKind::Variant(index, patterns) => {
                let (id, variant_tys) = match input_ty {
                    Type::Named(id, _, TypeStructure::Enumeration(variants)) => (id, variants),
                    _ => {
                        write!(f, "<error>")?;
                        return Ok(());
                    }
                };

                let ty = match file.declarations.types.get(id) {
                    Some(ty) => ty,
                    None => {
                        write!(f, "<error>")?;
                        return Ok(());
                    }
                };

                let ty_name = ty.name;

                let variant_names = match &ty.kind {
                    TypeDeclKind::Enumeration { variant_names, .. } => variant_names,
                    _ => {
                        write!(f, "<error>")?;
                        return Ok(());
                    }
                };

                let variant_name = variant_names
                    .iter()
                    .find_map(|(name, i)| (i == index).then_some(name.to_string()))
                    .unwrap_or_else(|| format!("<unknown variant #{}>", index.into_inner()));

                let value_tys = &variant_tys[index.into_inner()];

                write!(f, "({} {}", ty_name, variant_name)?;
                for (pattern, ty) in patterns.iter().zip(value_tys) {
                    write!(f, " ")?;
                    pattern.display_with(f, ty, file, indent)?;
                }
                write!(f, ")")?;
            }
            PatternKind::Or(left, right) => {
                write!(f, "(")?;
                left.display_with(f, input_ty, file, indent)?;
                write!(f, " or ")?;
                right.display_with(f, input_ty, file, indent)?;
                write!(f, ")")?;
            }
            PatternKind::Where(pattern, expr) => {
                write!(f, "(")?;
                pattern.display_with(f, input_ty, file, indent)?;
                write!(f, " where ")?;
                expr.display_with(f, file, indent)?;
                write!(f, ")")?;
            }
            PatternKind::Tuple(patterns) => {
                let value_tys = match input_ty {
                    Type::Tuple(tys) => tys,
                    _ => {
                        write!(f, "<error>")?;
                        return Ok(());
                    }
                };

                write!(f, "(")?;
                for ((index, pattern), ty) in patterns.iter().enumerate().zip(value_tys) {
                    if index != 0 {
                        write!(f, " , ")?;
                    }

                    pattern.display_with(f, ty, file, indent)?;
                }
                write!(f, ")")?;
            }
        }

        Ok(())
    }
}

impl TypeAnnotation {
    fn display_with(&self, f: &mut impl fmt::Write, file: &Program) -> fmt::Result {
        match &self.kind {
            TypeAnnotationKind::Error => write!(f, "<error>")?,
            TypeAnnotationKind::Placeholder => write!(f, "_")?,
            TypeAnnotationKind::Named(id, params) => {
                let name = match file.declarations.types.get(id) {
                    Some(ty) => ty.name,
                    None => {
                        write!(f, "<error>")?;
                        return Ok(());
                    }
                };

                write!(f, "({}", name)?;
                for ty in params {
                    write!(f, " ")?;
                    ty.display_with(f, file)?;
                }
                write!(f, ")")?;
            }
            TypeAnnotationKind::Parameter(id) => {
                let name = file
                    .declarations
                    .type_parameters
                    .get(id)
                    .and_then(|decl| decl.name.as_deref().map(ToString::to_string))
                    .unwrap_or_else(|| format!("<unknown type parameter #{}>", id.counter));

                write!(f, "{}", name)?;
            }
            TypeAnnotationKind::Builtin(id, params) => {
                let name = match file.declarations.builtin_types.get(id) {
                    Some(ty) => ty.name,
                    None => {
                        write!(f, "<error>")?;
                        return Ok(());
                    }
                };

                write!(f, "({}", name)?;
                for ty in params {
                    write!(f, " ")?;
                    ty.display_with(f, file)?;
                }
                write!(f, ")")?;
            }
            TypeAnnotationKind::Function(input, output) => {
                write!(f, "(")?;
                input.display_with(f, file)?;
                write!(f, " -> ")?;
                output.display_with(f, file)?;
                write!(f, ")")?;
            }
            TypeAnnotationKind::Tuple(tys) => {
                write!(f, "(")?;
                for (index, ty) in tys.iter().enumerate() {
                    if index != 0 {
                        write!(f, " , ")?;
                    }

                    ty.display_with(f, file)?;
                }
                write!(f, ")")?;
            }
        }

        Ok(())
    }
}
