---
id: a9Pw7IBT
type: text
locked: true
---

# How to use `Iterate`

The `Iterate` trait allows you to use the various iteration functions, like `each`, `transform`, `filter`, and `collect`, with your own container types:

---
id: zras8qnG
type: code
---

[help "An iterator that produces a value the specified number of times."]
Repeat : A => type {
  value :: A
  times :: Natural
}

A => instance (Iterate (Repeat A) A) : { value times } -> {
  counter : mutable 0

  iterator (() -> {
    if (get counter = times) { None } {
      increment! counter
      Some value
    }
  })
}

repeat : Repeat {
  value : "Hello, world!"
  times : 5
}

repeat . each show

---
id: OI2ju7pw
type: text
locked: true
---

Inside the `Iterate` instance, you call `iterator` with a function that will be called each iteration until it returns `None`. Usually, you need to use internal mutation to keep track of the iterator's progress.

`Iterate` can also be used to build new "adapters" that transform the contents of another iterator, producing a new iterator. You can use `next` to manually retrieve the next item in the iterator if it exists:

---
id: OOx5eBMd
type: code
---

[help "Keep taking items from the iterator until it runs out of elements or the predicate is `False`."]
take-while :: Collection Element where (Iterate Collection Element) => (Element -> Boolean) -> Collection -> Iterator Element
take-while : keep? collection -> {
  i : Iterate collection
  iterator (() -> {
    when (i . next) {
      Some element -> if (keep? element) (Some element) None
      None -> None
    }
  })
}

list 1 2 3 4 5 . take-while (n -> n <= 3) . each show
