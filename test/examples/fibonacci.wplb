; Fibonacci sequence
;
; Since this is getting complicated, here is the (functionally) equivalent
; Wipple code:
;
;     fib : n -> if n <= 1 n (fib n - 1) + (fib n - 2)
;     show (fib 10)

(version "0.0.0")

(def if extern "logic" "if")
(def lte extern "math" "lte")
(def sub extern "math" "sub")
(def add extern "math" "add")
(def show extern "io" "show")

(def fib block (def n)
  (use (const num 1))         ; store 1 in $1
  (call lte n $1)             ; call 'lte' with $0 (n) and $1 (1), which stores
                              ;  its result in $2
  (thunk fib-true n)          ; store a thunk to 'fib-true' with a copy of $0
                              ;  (n) in $3
  (thunk fib-false n)         ; store a thunk to 'fib-false' with a copy of $0
                              ;  (n) in $4
  (call if $2 $3 $4)          ; call 'if' with $2 (n <= 1), $3 (fib-true) and $4
                              ;  (fib-false), which stores its result in $5
  (enter $5)                  ; enter $5 (thunk), storing the result in $6
  (exit $6))                  ; exit the block, returning $6

(def fib-true block (def n)
  (exit n))                   ; exit the block, returning $0 (n)

(def fib-false block (def n)
  (thunk fib)                 ; store a thunk to 'fib' in $1
  (use (const num 1))         ; store 1 in $2
  (call sub n $2)             ; call 'sub' with $0 (n) and $2 (1), which stores
                              ;  its result in $3
  (enter $1 $3)               ; enter $1 ('fib') with $3 (n - 1), storing the
                              ;  result in $4
  (use (const num 2))         ; store 2 in $5
  (call sub n $5)             ; call 'sub' with $0 (n) and $5 (2), which stores
                              ;  its result in $6
  (enter $1 $6)               ; enter $1 ('fib') with $6 (n - 2), storing the
                              ;  result in $7
  (call add $4 $7)            ; call 'add' with $4 (fib n - 1) and $7
                              ;  (fib n - 2), which stores its result in $8
  (exit $8))                  ; exit the block, returning $8 ((fib n - 1) +
                              ;  (fib n - 2))

(block
  (thunk fib)                 ; store a thunk to 'fib' in $0
  (use (const num 15))        ; store 10 in $1
  (enter $0 $1)               ; enter $0 ('fib') with $1 (10), storing the
                              ;  result in $2
  (call show $2)              ; call 'show' with $2
  (exit))                     ; exit the block
