[[no-std]]

use "util"
use "fp"
use "mutable"
use "list"
use "logic"
use "repeat"

[help "A container for an iterable value that produces the `next` value on demand."]
[help-group "Collections"]
[help-playground "https://wipple.dev/std/examples/iterate.txt"]
Iterator : Element => type { next :: () -> Maybe Element }

[help "Create an iterator from a function."]
[help-group "Collections"]
[help-playground "https://wipple.dev/std/examples/iterate.txt"]
iterator :: Element => (() -> Maybe Element) -> Iterator Element
iterator : next -> Iterator { next }

[help "Retrieve the next item in an iterator."]
[help-group "Collections"]
[help-playground "https://wipple.dev/std/examples/iterate.txt"]
next :: Element => Iterator Element -> Maybe Element
next : { next } -> next ()

[help "Implement this trait to enable traversing your collection type."]
[help-group "Collections"]
[help-playground "https://wipple.dev/std/examples/iterate.txt"]
Iterate : Container (infer Element) => trait (Container -> Iterator Element)

Element => instance (Iterate (Iterator Element) Element) : it

[help "Transform each item in an iterator, producing a new iterator."]
[help-group "Collections"]
transform :: Container (infer Element) Result where (Iterate Container Element) => (Element -> Result) -> Container -> Iterator Result
transform : f container -> {
  base : Iterate container

  iterator (() -> when (next base) {
    Some x -> Some (f x)
    None -> None
  })
}

[help "Keep only the items in an iterator that satisfy the provided condition."]
[help-group "Collections"]
filter :: Container (infer Element) where (Iterate Container Element) => (Element -> Boolean) -> Container -> Iterator Element
filter : include? container -> {
  base : Iterate container

  iterator (() -> repeat {
    when (next base) {
      Some x -> if (include? x) (Break (Some x)) Continue
      None -> Break None
    }
  })
}

[help "Transform each item in an iterator, keeping only the items that aren't `None`."]
[help-group "Collections"]
try-filter :: Container (infer Element) Result where (Iterate Container Element) => (Element -> Maybe Result) -> Container -> Iterator Result
try-filter : transform container -> {
  base : Iterate container

  iterator (() -> repeat {
    when (next base) {
      Some x -> when (transform x) {
        Some x -> (Break (Some x))
        None -> Continue
      }
      None -> Break None
    }
  })
}

[help "Flatten an iterator of iterators."]
[help-group "Collections"]
flatten :: Outer (infer Inner) (infer Element) where (Iterate Outer Inner) (Iterate Inner Element) => Outer -> Iterator Element
flatten : outer-container -> {
  outer : Iterate outer-container

  when (next outer) {
    Some inner-container -> {
      inner : mutable (Iterate inner-container)

      iterator (() -> repeat {
        when (next (get inner)) {
          Some x -> Break (Some x)
          None -> when (next outer) {
            Some inner-container -> {
              inner . set! (Iterate inner-container)
              Continue
            }
            None -> Break None
          }
        }
      })
    }
    None -> iterator (just None)
  }
}

[help "Reduce an iterator down to a single item."]
[help-group "Collections"]
reduce :: Container Element Result where (Iterate Container Element) => Result -> (Element -> Result -> Result) -> Container -> Result
reduce : result f container -> {
  reduce-helper :: Element Result => Result -> (Element -> Result -> Result) -> Iterator Element -> Result
  reduce-helper : result f iterator -> when (next iterator) {
    Some next -> reduce-helper (f next result) f iterator
    None -> result
  }

  reduce-helper result f (Iterate container)
}

[help "Find the sum of all the numbers in an iterator."]
[help-group "Collections"]
sum :: Container N where (Iterate Container N) (Numeric N) (Add N N N) => Container -> N
sum : reduce (zero of Numeric) Add

[help "Implement this trait to enable reducing an iterator into your collection type."]
[help-group "Collections"]
[help-playground "https://wipple.dev/std/examples/collect.txt"]
Collect : (infer Element) Container => trait (Iterator Element -> Container)

[help "Collect an iterator into a single value, like a `List`."]
[help-group "Collections"]
[help-playground "https://wipple.dev/std/examples/collect.txt"]
collect :: Input (infer Element) Output where (Collect Element Output) (Iterate Input Element) => Input -> Output -- FIXME: bound order shouldn't matter, but putting `Iterate` first breaks type inference
collect : input -> Collect (Iterate input)

Element => instance (Collect Element (List Element)) : iterator -> {
  l : mutable (list)
  repeat {
    when (next iterator) {
      Some x -> {
        l . append! x
        Continue
      }
      None -> Break ()
    }
  }

  get l
}

Element => instance (Iterate (List Element) Element) : l -> {
  index : mutable 0

  iterator (() -> when (l . nth (get index)) {
    Some element -> {
      increment! index
      Some element
    }
    None -> None
  })
}

A => instance (Iterate (Maybe A) A) : maybe -> {
  maybe : mutable maybe
  iterator (() -> take! maybe)
}

instance (Collect () ()) : iterator -> {
  repeat {
    when (next iterator) {
      Some () -> Continue
      None -> Break ()
    }
  }
}

[help "Perform an action for each item in an iterator."]
[help-group "Collections"]
[help-playground "https://wipple.dev/std/examples/each.txt"]
each :: Container (infer Element) where (Iterate Container Element) => (Element -> ()) -> Container -> ()
each : f container -> container . transform f . collect

[help "Split an iterator into groups of consecutive items satisfying a condition."]
[help-group "Collections"]
split-by :: Collection (infer Element) where (Iterate Collection Element) => (Element -> Boolean) -> Collection -> Iterator (List Element)
split-by : separator? -> collection -> {
  base : Iterate collection
  group : mutable (Some (list))

  iterator (() -> repeat {
    when (next base) {
      Some x -> {
        if (separator? x) { Break (take! group) } {
          group . set! (Some (when (get group) {
            Some inner -> inner . append x
            None -> list x
          }))

          Continue
        }
      }
      None -> Break (take! group)
    }
  })
}

[help "Split an iterator into groups of consecutive items equal to a value."]
[help-group "Collections"]
split :: Collection (infer Element) where (Iterate Collection Element) (Equal Element) => Element -> Collection -> Iterator (List Element)
split : separator -> split-by (x -> x = separator)

[help "Count the number of items in an iterator."]
[help-group "Collections"]
count :: Collection (infer Element) where (Iterate Collection Element) => Collection -> Natural
count : collection -> {
  iterator : Iterate collection

  count : mutable 0
  repeat {
    when (next iterator :: Maybe Element) {
      Some _ -> {
        increment! count
        Continue
      }
      None -> Break ()
    }
  }

  get count
}

[help "Collect two iterators into a single value."]
[help-group "Collections"]
join :: A B (infer Element) (C : A) where (Iterate A Element) (Iterate B Element) (Collect Element C) => A -> B -> C
join : a b -> collect (flatten (list (Iterate a) (Iterate b)))

[specialize]
count :: Element => List Element -> Natural
count : list -> intrinsic "list-count" list
