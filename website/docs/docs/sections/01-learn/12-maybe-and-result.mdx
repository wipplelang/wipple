## Maybe and Result

It's time to put together all of our knowledge and learn about two fundamental types in Wipple, `Maybe` and `Result`. Almost every Wipple program uses these two types extensively!

### Maybe

Let's say we have a program that asks you to input a number. But what happens if you _don't_ provide a number? How can we represent the _absence_ of a value in our program?

Your first thought might be to designate a special number to represent the absence, like `0` or `-1`. But this isn't just confusing, it also invites bugs. Luckily, Wipple has a special enumeration, called `Maybe`, that's designed to handle this situation! Here is `Maybe` in its entirety:

```wipple
Maybe : A => type {
	Some A
	None
}

use Maybe
```

What's that `A` after the `Some`? Well, in Wipple, enums can store values alongside the variant. This is an extremely powerful concept that makes it impossible for your program to be in an invalid state. `A` represents the type of the value to be stored alongside `Some`! You might see where this is going — `None` has no associated values and thus represents the absence of one.

So how to we get the value out of the `Some`? We can use pattern matching!

```wipple
display-number : input -> show (when input {
	Some number -> format "the number you provided is _" number
	None -> "you didn't provide a number"
})

display-number (Some 1)
display-number None
```

If you're sure that there's a value inside a `Maybe`, then you can crash the program if `None` is found instead.

```wipple
input :: Maybe Number
input : ...

when input {
	Some text -> ...
	None -> crash "uh oh"
}
```

This can be expressed more succinctly using `expect`, which will crash the program with the provided error message if `None` is found:

```wipple
no-number :: Maybe Number
no-number : None

definitely-a-number : expect "oh no" no-number -- oh no
```

Or you can use `unwrap`, which provides a default error message:

```wipple
definitely-a-number : unwrap no-number -- called `unwrap` on `None`
```

### Result

Returning `Maybe` from a function is useful if there's an error while processing the input — for example, if the user's input is `five` instead of `5`. But there's a better way to express errors in Wipple, and that's with the `Result` type!

```wipple
Result : Success Failure => type {
	OK Success
	Error Failure
}
```

Instead of `Some` and `None`, `Result` has `OK` (representing success) and `Error` (representing failure). Otherwise, you use them in the same way!

```wipple
Clamp-Error : type {
	Too-Small
	Too-Large
}

use Clamp-Error

instance Show Clamp-Error : error -> when error {
	Too-Small -> "too small"
	Too-Large -> "too large"
}

clamp : min -> max -> n ->
	if (n > min)
		(if (n < max) (OK n) (Error Too-Large))
		(Error Too-Small)

single-digit : clamp -10 10

show (single-digit 5)
show (single-digit 20)
show (unwrap (single-digit -42))
```
